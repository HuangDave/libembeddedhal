<!-- HTML header for doxygen 1.9.2-->
<!DOCTYPE html
  PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "https://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
  <meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8" />
  <meta http-equiv="X-UA-Compatible" content="IE=11" />
  <meta name="generator" content="Doxygen 1.9.4" />
  <meta name="viewport" content="width=device-width, initial-scale=1" />
  <title>My Project: hal::serial Class Reference</title>
  <link href="tabs.css" rel="stylesheet" type="text/css" />
  <script type="text/javascript" src="jquery.js"></script>
  <script type="text/javascript" src="dynsections.js"></script>
  <link href="navtree.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="resize.js"></script>
<script type="text/javascript" src="navtreedata.js"></script>
<script type="text/javascript" src="navtree.js"></script>
  <link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
  <link href="doxygen.css" rel="stylesheet" type="text/css" />
  <link href="doxygen-awesome.css" rel="stylesheet" type="text/css"/>
<link href="doxygen-awesome-sidebar-only.css" rel="stylesheet" type="text/css"/>
<link href="doxygen-awesome-sidebar-only-darkmode-toggle.css" rel="stylesheet" type="text/css"/>
<link href="doxygen-awesome-sidebar-only-darkmode-toggle.css" rel="stylesheet" type="text/css"/>
  <script type="text/javascript" src="doxygen-awesome-darkmode-toggle.js"></script>
  <script type="text/javascript">
    DoxygenAwesomeDarkModeToggle.init()
  </script>
</head>
<body>
    <div id="top">
      <!-- do not remove this div, it is closed by doxygen! -->
      <div id="titlearea">
        <table cellspacing="0" cellpadding="0">
          <tbody>
            <tr style="height: 56px;">
              <td id="projectalign" style="padding-left: 0.5em;">
                <div id="projectname">My Project
                </div>
              </td>
            </tr>
          </tbody>
        </table>
      </div>
      <!-- end header part --><!-- Generated by Doxygen 1.9.4 -->
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
var searchBox = new SearchBox("searchBox", "search",'Search','.html');
/* @license-end */
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
$(function() {
  initMenu('',true,false,'search.php','Search');
  $(document).ready(function() { init_search(); });
});
/* @license-end */
</script>
<div id="main-nav"></div>
</div><!-- top -->
<div id="side-nav" class="ui-resizable side-nav-resizable">
  <div id="nav-tree">
    <div id="nav-tree-contents">
      <div id="nav-sync" class="sync"></div>
    </div>
  </div>
  <div id="splitbar" style="-moz-user-select:none;" 
       class="ui-resizable-handle">
  </div>
</div>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
$(document).ready(function(){initNavTree('classhal_1_1serial.html',''); initResizable(); });
/* @license-end */
</script>
<div id="doc-content">
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

<div class="header">
  <div class="summary">
<a href="#nested-classes">Classes</a> &#124;
<a href="#pub-methods">Public Member Functions</a> &#124;
<a href="classhal_1_1serial-members.html">List of all members</a>  </div>
  <div class="headertitle"><div class="title">hal::serial Class Reference<span class="mlabels"><span class="mlabel">abstract</span></span><div class="ingroups"><a class="el" href="group__serial.html">Serial</a></div></div></div>
</div><!--header-->
<div class="contents">

<p>Hardware abstract interface for the serial communication protocol.  
 <a href="classhal_1_1serial.html#details">More...</a></p>

<p><code>#include &lt;<a class="el" href="serial_2interface_8hpp_source.html">interface.hpp</a>&gt;</code></p>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="nested-classes" name="nested-classes"></a>
Classes</h2></td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structhal_1_1serial_1_1bytes__available__t.html">bytes_available_t</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structhal_1_1serial_1_1settings.html">settings</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Generic settings for a standard serial device.  <a href="structhal_1_1serial_1_1settings.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="pub-methods" name="pub-methods"></a>
Public Member Functions</h2></td></tr>
<tr class="memitem:ad3d247776562df9621fd002333677ca5"><td class="memItemLeft" align="right" valign="top"><a class="el" href="namespacehal.html#a1607e3547737e35235f946a9c67b61cf">status</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classhal_1_1serial.html#ad3d247776562df9621fd002333677ca5">configure</a> (const <a class="el" href="structhal_1_1serial_1_1settings.html">settings</a> &amp;p_settings) noexcept</td></tr>
<tr class="memdesc:ad3d247776562df9621fd002333677ca5"><td class="mdescLeft">&#160;</td><td class="mdescRight">Configure serial to match the settings supplied.  <a href="classhal_1_1serial.html#ad3d247776562df9621fd002333677ca5">More...</a><br /></td></tr>
<tr class="separator:ad3d247776562df9621fd002333677ca5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6ba7623501b3dc5c467bb91cf4cb8c60"><td class="memItemLeft" align="right" valign="top"><a class="el" href="namespacehal.html#a22b1708df761b2dc40dd4afa2ac0c401">result</a>&lt; size_t &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classhal_1_1serial.html#a6ba7623501b3dc5c467bb91cf4cb8c60">write</a> (std::span&lt; const <a class="el" href="group__utility.html#gaa21f8ca97410869aabb284a575b2021d">hal::byte</a> &gt; p_data) noexcept</td></tr>
<tr class="memdesc:a6ba7623501b3dc5c467bb91cf4cb8c60"><td class="mdescLeft">&#160;</td><td class="mdescRight">Write data to the transmitter line of the serial port.  <a href="classhal_1_1serial.html#a6ba7623501b3dc5c467bb91cf4cb8c60">More...</a><br /></td></tr>
<tr class="separator:a6ba7623501b3dc5c467bb91cf4cb8c60"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a05b027b5f5d575aa5d47f98a42010b78"><td class="memItemLeft" align="right" valign="top"><a class="el" href="structhal_1_1serial_1_1bytes__available__t.html">bytes_available_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classhal_1_1serial.html#a05b027b5f5d575aa5d47f98a42010b78">bytes_available</a> () noexcept</td></tr>
<tr class="memdesc:a05b027b5f5d575aa5d47f98a42010b78"><td class="mdescLeft">&#160;</td><td class="mdescRight">The number of bytes that have been buffered.  <a href="classhal_1_1serial.html#a05b027b5f5d575aa5d47f98a42010b78">More...</a><br /></td></tr>
<tr class="separator:a05b027b5f5d575aa5d47f98a42010b78"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a245de557152f925be91ff552535ed53a"><td class="memItemLeft" align="right" valign="top"><a class="el" href="namespacehal.html#a22b1708df761b2dc40dd4afa2ac0c401">result</a>&lt; std::span&lt; <a class="el" href="group__utility.html#gaa21f8ca97410869aabb284a575b2021d">hal::byte</a> &gt; &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classhal_1_1serial.html#a245de557152f925be91ff552535ed53a">read</a> (std::span&lt; <a class="el" href="group__utility.html#gaa21f8ca97410869aabb284a575b2021d">hal::byte</a> &gt; p_data) noexcept</td></tr>
<tr class="memdesc:a245de557152f925be91ff552535ed53a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Copy bytes from working buffer into passed buffer.  <a href="classhal_1_1serial.html#a245de557152f925be91ff552535ed53a">More...</a><br /></td></tr>
<tr class="separator:a245de557152f925be91ff552535ed53a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a808aec1ec3948baf8b55d115fc3a17da"><td class="memItemLeft" align="right" valign="top"><a class="el" href="namespacehal.html#a1607e3547737e35235f946a9c67b61cf">status</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classhal_1_1serial.html#a808aec1ec3948baf8b55d115fc3a17da">flush</a> () noexcept</td></tr>
<tr class="memdesc:a808aec1ec3948baf8b55d115fc3a17da"><td class="mdescLeft">&#160;</td><td class="mdescRight">Flush working buffer.  <a href="classhal_1_1serial.html#a808aec1ec3948baf8b55d115fc3a17da">More...</a><br /></td></tr>
<tr class="separator:a808aec1ec3948baf8b55d115fc3a17da"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<div class="textblock"><p >Hardware abstract interface for the serial communication protocol. </p>
<p >Use this interface for hardware that implements a serial protocol like UART, RS232, RS485 and others that use a similar communication protocol but may use different voltage schemes.</p>
<p >This interface only works 8-bit serial data frames.</p>
<p >Due to the asynchronous and unformatted nature of serial communication protocols, all implementations of serial devices must be buffered. Buffered, in this case, is defined as automatic storage of received bytes without direct application intervention.</p>
<p >All implementations MUST allow the user to supply their own buffer of arbitrary size up to the limits of what hardware can support. This allows a developer the ability to tailored the buffer size to the needs of the application.</p>
<p >Examples of buffering schemes are:</p>
<ul>
<li>Using DMA to copy data from a serial peripheral to a region of memory</li>
<li>Using interrupts when a serial peripheral's queue has filled to a point </li>
</ul>
</div><h2 class="groupheader">Member Function Documentation</h2>
<a id="a05b027b5f5d575aa5d47f98a42010b78" name="a05b027b5f5d575aa5d47f98a42010b78"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a05b027b5f5d575aa5d47f98a42010b78">&#9670;&nbsp;</a></span>bytes_available()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structhal_1_1serial_1_1bytes__available__t.html">bytes_available_t</a> hal::serial::bytes_available </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>The number of bytes that have been buffered. </p>
<dl class="section return"><dt>Returns</dt><dd><a class="el" href="structhal_1_1serial_1_1bytes__available__t.html">bytes_available_t</a> - number of bytes that can be read out of this serial port as well as the capacity of the serial port. </dd></dl>

</div>
</div>
<a id="ad3d247776562df9621fd002333677ca5" name="ad3d247776562df9621fd002333677ca5"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad3d247776562df9621fd002333677ca5">&#9670;&nbsp;</a></span>configure()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="namespacehal.html#a1607e3547737e35235f946a9c67b61cf">status</a> hal::serial::configure </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="structhal_1_1serial_1_1settings.html">settings</a> &amp;&#160;</td>
          <td class="paramname"><em>p_settings</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Configure serial to match the settings supplied. </p>
<p >Implementing drivers must verify if the settings can be applied to hardware before modifying the hardware. This will ensure that if this operation fails, the state of the serial device has not changed.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">p_settings</td><td>- settings to apply to serial driver </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>status - success or failure </dd></dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname">std::errc::invalid_argument</td><td>if the settings could not be achieved </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a808aec1ec3948baf8b55d115fc3a17da" name="a808aec1ec3948baf8b55d115fc3a17da"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a808aec1ec3948baf8b55d115fc3a17da">&#9670;&nbsp;</a></span>flush()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="namespacehal.html#a1607e3547737e35235f946a9c67b61cf">status</a> hal::serial::flush </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Flush working buffer. </p>
<p >The behavior of flushing the internal working buffer is this:</p>
<ul>
<li>Set the internal circular buffer implementation to an "empty" state.</li>
<li>After this call, so long as data is not received at the same time, <a class="el" href="classhal_1_1serial.html#a05b027b5f5d575aa5d47f98a42010b78" title="The number of bytes that have been buffered.">bytes_available()</a> will report to zero bytes</li>
<li>Will clear any received data stored in hardware registers.</li>
<li>Will ensure that this operation is as fast as possible, meaning it will not zero out the contents of the internal working buffer.</li>
</ul>
<dl class="section return"><dt>Returns</dt><dd>status - success or failure </dd></dl>

</div>
</div>
<a id="a245de557152f925be91ff552535ed53a" name="a245de557152f925be91ff552535ed53a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a245de557152f925be91ff552535ed53a">&#9670;&nbsp;</a></span>read()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="namespacehal.html#a22b1708df761b2dc40dd4afa2ac0c401">result</a>&lt; std::span&lt; <a class="el" href="group__utility.html#gaa21f8ca97410869aabb284a575b2021d">hal::byte</a> &gt; &gt; hal::serial::read </td>
          <td>(</td>
          <td class="paramtype">std::span&lt; <a class="el" href="group__utility.html#gaa21f8ca97410869aabb284a575b2021d">hal::byte</a> &gt;&#160;</td>
          <td class="paramname"><em>p_data</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Copy bytes from working buffer into passed buffer. </p>
<p >This operation copies the bytes from the serial driver's internal working buffer to the buffer supplied. This call will subtract from the number returned from <a class="el" href="classhal_1_1serial.html#a05b027b5f5d575aa5d47f98a42010b78" title="The number of bytes that have been buffered.">bytes_available()</a> function.</p>
<p >If the length of this buffer is greater than bytes available, then the buffer is filled up to the length returned by <a class="el" href="classhal_1_1serial.html#a05b027b5f5d575aa5d47f98a42010b78" title="The number of bytes that have been buffered.">bytes_available()</a>. The rest of the buffer is left untouched.</p>
<p >If a frame error has occurred at any point during serial reception, this function will throw a <code>std::errc::io_error</code> value. The contents of the internal working buffer as well as the values for bytes_available will stay the same with no copy into the supplied buffered taking place. The frame error will be internally cleared after its occurrence. A subsequent call to <a class="el" href="classhal_1_1serial.html#a245de557152f925be91ff552535ed53a" title="Copy bytes from working buffer into passed buffer.">read()</a> will read out the contents of the buffer although the data inside may be corrupt. Options are to flush the buffer and attempt reception again or read out the potentially corrupted data and parse it as needed. The choice of operations here are very application and driver specific.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">p_data</td><td>- Buffer to read bytes back from </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><a class="el" href="namespacehal.html#a22b1708df761b2dc40dd4afa2ac0c401">result&lt;std::span&lt;hal::byte&gt;&gt;</a> - The address will ALWAYS be the same as p_data and the length will be equal to the number of bytes read from the buffer. </dd></dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname">std::errc::io_error</td><td>- a frame error occurred at some point during reception. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a6ba7623501b3dc5c467bb91cf4cb8c60" name="a6ba7623501b3dc5c467bb91cf4cb8c60"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6ba7623501b3dc5c467bb91cf4cb8c60">&#9670;&nbsp;</a></span>write()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="namespacehal.html#a22b1708df761b2dc40dd4afa2ac0c401">result</a>&lt; size_t &gt; hal::serial::write </td>
          <td>(</td>
          <td class="paramtype">std::span&lt; const <a class="el" href="group__utility.html#gaa21f8ca97410869aabb284a575b2021d">hal::byte</a> &gt;&#160;</td>
          <td class="paramname"><em>p_data</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Write data to the transmitter line of the serial port. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">p_data</td><td>- data to be transmitted over the serial port </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>result&lt;size_t&gt; - the number of bytes transmitted </dd></dl>

</div>
</div>
<hr/>The documentation for this class was generated from the following file:<ul>
<li>/github/workspace/include/libhal/serial/<a class="el" href="serial_2interface_8hpp_source.html">interface.hpp</a></li>
</ul>
</div><!-- contents -->
</div><!-- doc-content -->
<!-- start footer part -->
<div id="nav-path" class="navpath"><!-- id is needed for treeview function! -->
  <ul>
    <li class="navelem"><a class="el" href="namespacehal.html">hal</a></li><li class="navelem"><a class="el" href="classhal_1_1serial.html">serial</a></li>
    <li class="footer">Generated by <a href="https://www.doxygen.org/index.html"><img class="footer" src="doxygen.svg" width="104" height="31" alt="doxygen"/></a> 1.9.4 </li>
  </ul>
</div>
</body>
</html>
