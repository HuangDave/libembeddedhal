[{"content":"TBD\n","description":"","tags":null,"title":"Getting Started","uri":"/libembeddedhal/installation/getting_started/"},{"content":"Quick Start TBD\n","description":"","tags":null,"title":"Installation","uri":"/libembeddedhal/installation/"},{"content":"TBD\n","description":"","tags":null,"title":"Flashing","uri":"/libembeddedhal/installation/flashing/"},{"content":"Guides TBD\n","description":"","tags":null,"title":"Guides","uri":"/libembeddedhal/guides/"},{"content":"API The following chapter contains detailed API documentation for every class and function in the code base. These descriptions include, but are not limited to, descriptions of the available classes, their method, what parameters those methods take, and a description of those parameters and how to use them. These sort of descriptions are also available for functions, type definitions, structures and inline defined variables within header files.\nClasses The classes section contains every single documented class in the project. This area can be quite large and hard to navigate unless you know exactly what you are looking for. If you are not sure exactly what you are looking for but know what catagory of library you are looking for, use the modules section.\nModules Modules chapter categorizes drivers in like groups which makes navigation easier.\n","description":"","tags":null,"title":"API","uri":"/libembeddedhal/api/"},{"content":"TBD\n","description":"","tags":null,"title":"Debugging","uri":"/libembeddedhal/installation/jtag/"},{"content":"TBD\n","description":"","tags":null,"title":"Exploring the Ecosystem","uri":"/libembeddedhal/installation/exploring_the_ecosystem/"},{"content":"TBD\n","description":"","tags":null,"title":"Creating a Device Driver","uri":"/libembeddedhal/expanding/creating_device/"},{"content":"TBD\n","description":"","tags":null,"title":"Creating a Project","uri":"/libembeddedhal/guides/new_project/"},{"content":"Design Documentation This section goes into detail on the design choices of each aspect of each part of the libembeddedhal library. This section will go into why things are the way they are. If you are looking to just know how to use aspects of libembeddedhal please see the “guides” and “api” chapters.\nThis section is meant to explain to users of libembeddedhal why certain design choices were made, what the alternatives options were, what are the pros and cons of a system and why the pros outweigh the cons. If you disagree with these design choices, feel free to add an issue to the official repo.\n","description":"","tags":null,"title":"Design","uri":"/libembeddedhal/design/"},{"content":"TBD\n","description":"","tags":null,"title":"Driver Interface Design","uri":"/libembeddedhal/design/driver_design/"},{"content":"Expanding the Ecosystem TBD\n","description":"","tags":null,"title":"Expanding the Ecosystem","uri":"/libembeddedhal/expanding/"},{"content":"Contributing to libembeddedhal Code of conduct Please read the CODE_OF_CONDUCT.md file before contributing.\nStyle Guide  ","description":"","tags":null,"title":"Contributing","uri":"/libembeddedhal/contribution/"},{"content":"TBD\n","description":"","tags":null,"title":"Creating a Platform","uri":"/libembeddedhal/expanding/creating_platform/"},{"content":"TBD\n","description":"","tags":null,"title":"Error Handling Design","uri":"/libembeddedhal/design/error_handling_design/"},{"content":"TBD\n","description":"","tags":null,"title":"How to Use Drivers","uri":"/libembeddedhal/guides/driver_usage/"},{"content":"TBD\n","description":"","tags":null,"title":"Creating a Utility Library","uri":"/libembeddedhal/expanding/creating_utilities/"},{"content":"TBD\n","description":"","tags":null,"title":"Driver Wrappers Design","uri":"/libembeddedhal/design/driver_wrappers/"},{"content":"TBD\n","description":"","tags":null,"title":"Error Handling","uri":"/libembeddedhal/guides/error_handling/"},{"content":"TBD\n","description":"","tags":null,"title":"Multiplatform Applications","uri":"/libembeddedhal/guides/multiplatform_apps/"},{"content":"TBD\n","description":"","tags":null,"title":"Unit Testing","uri":"/libembeddedhal/guides/unit_testing/"},{"content":"TBD\n","description":"","tags":null,"title":"Handwritten Driver Mocks","uri":"/libembeddedhal/design/handmade_mocks/"},{"content":"","description":"","tags":null,"title":"Categories","uri":"/libembeddedhal/categories/"},{"content":" namespace embed  class adc Analog to Digital Converter (ADC) hardware abstraction interface. struct bit_depth A type based on bit width that contains a value. class bit_limits class can Controller Area Network (CAN bus) hardware abstraction interface.  struct message_t Attributes of a can message.   class can_network can_network is a canbus message receiver handler and  class node_t A can network node stores the can messages in a lock free way.   struct can_settings Generic settings for a can peripheral. class counter Counter hardware abstraction interface. Use this interface for devices and peripherals that have counting capabilities. Such devices can count up or down. Useful for keeping time. Expect counters to overflow when they reach the end of counting register’s limits. class dac Digital to Analog Converter (DAC) hardware abstraction interface. class driver The basis class for all peripheral, device and system drivers in libembeddedhal. class full_scale A bit resolution erased representation of a precentage value using only integral arithmetic. class i2c Inter-integrated Circuit (I2C) or Two Wire Interface (TWI) communication protocol hardware abstract interface. struct i2c_settings Generic settings for a standard I2C device. class input_pin Digital input pin hardware abstraction. struct input_pin_settings Generic settings for input pins. class interrupt_pin Digital interrupt pin hardware abstraction. struct interrupt_pin_settings Generic settings for interrupt pins. struct invalid_option_t Used for defining static_asserts that should always fail, but only if the static_assert line is hit via if constexpr control block. Prefer to NOT use this directly but to use invalid_option instead. struct no_settings An empty settings structure used to indicate that a driver or interface does not have generic settings. class output_pin Digital output pin hardware abstraction. struct output_pin_settings Generic settings for output pins. class pwm Pulse Width Modulation (PWM) channel hardware abstraction. class serial Serial communication protocol hardware abstract interface. struct serial_settings Generic settings for a standard serial device. class spi Serial peripheral interface (SPI) communication protocol hardware abstract interface. struct spi_settings Generic settings for a standard SPI device. class static_callable General class which will be used to allow for signature to be used and then split by the below class. class static_callable\u003c owner_class, reference_designator, return_t(args_t… p_args)\u003e Specialization of static_callable with the return type and arguments split up. class static_memory_resource The static_memory_resource is the polymorphic memory resource allocator that allows libembeddedhal’s libraries to use a C++ standard container such as std::pmr::vector, std::pmr::string, std::pmr::unordered_map, and more without requiring dynamic memory allocation from the heap. It provides a simple way to create an allocator with built in storage, with its size indicated by a single template parameter. It also provides statistics regarding the amount of memory allocated such that developers can determine if they need to reduce or increase the size of the buffer. Memory statistics can also give programs the insight into how much memory space is available and make decisions based on that. In the event that the memory of the static allocator is exceeded, a std::bad_alloc excpetion is thrown. namespace this_thread  struct global_clocks structure containing internal clock variables and functions   class timer Timer hardware abstraction interface.     Updated on 2021-12-10 at 15:52:40 +0000\n","description":"","tags":null,"title":"Classes","uri":"/libembeddedhal/api/classes/"},{"content":"embed Namespace Reference\nNamespaces    Name     embed::this_thread    Classes     Name     class embed::adc Analog to Digital Converter (ADC) hardware abstraction interface.   struct embed::can_settings Generic settings for a can peripheral.   class embed::can Controller Area Network (CAN bus) hardware abstraction interface.   class embed::can_network can_network is a canbus message receiver handler and   class embed::counter Counter hardware abstraction interface. Use this interface for devices and peripherals that have counting capabilities. Such devices can count up or down. Useful for keeping time. Expect counters to overflow when they reach the end of counting register’s limits.   class embed::dac Digital to Analog Converter (DAC) hardware abstraction interface.   struct embed::invalid_option_t Used for defining static_asserts that should always fail, but only if the static_assert line is hit via if constexpr control block. Prefer to NOT use this directly but to use invalid_option instead.   struct embed::no_settings An empty settings structure used to indicate that a driver or interface does not have generic settings.   class embed::driver The basis class for all peripheral, device and system drivers in libembeddedhal.   class embed::bit_limits   struct embed::bit_depth A type based on bit width that contains a value.   class embed::full_scale A bit resolution erased representation of a precentage value using only integral arithmetic.   struct embed::input_pin_settings Generic settings for input pins.   struct embed::output_pin_settings Generic settings for output pins.   struct embed::interrupt_pin_settings Generic settings for interrupt pins.   class embed::input_pin Digital input pin hardware abstraction.   class embed::output_pin Digital output pin hardware abstraction.   class embed::interrupt_pin Digital interrupt pin hardware abstraction.   struct embed::i2c_settings Generic settings for a standard I2C device.   class embed::i2c Inter-integrated Circuit (I2C) or Two Wire Interface (TWI) communication protocol hardware abstract interface.   class embed::pwm Pulse Width Modulation (PWM) channel hardware abstraction.   struct embed::serial_settings Generic settings for a standard serial device.   class embed::serial Serial communication protocol hardware abstract interface.   struct embed::spi_settings Generic settings for a standard SPI device.   class embed::spi Serial peripheral interface (SPI) communication protocol hardware abstract interface.   class embed::static_callable General class which will be used to allow for signature to be used and then split by the below class.   class embed::static_callable\u003c owner_class, reference_designator, return_t(args_t… p_args)\u003e Specialization of static_callable with the return type and arguments split up.   class embed::static_memory_resource The static_memory_resource is the polymorphic memory resource allocator that allows libembeddedhal’s libraries to use a C++ standard container such as std::pmr::vector, std::pmr::string, std::pmr::unordered_map, and more without requiring dynamic memory allocation from the heap. It provides a simple way to create an allocator with built in storage, with its size indicated by a single template parameter. It also provides statistics regarding the amount of memory allocated such that developers can determine if they need to reduce or increase the size of the buffer. Memory statistics can also give programs the insight into how much memory space is available and make decisions based on that. In the event that the memory of the static allocator is exceeded, a std::bad_alloc excpetion is thrown.   class embed::timer Timer hardware abstraction interface.    Types     Name     enum class pin_resistor { none = 0, pull_down, pull_up}Set of possible pin mode resistor settings.    Functions     Name     constexpr bool is_platform(std::string_view p_platform)Determines if the current application was built for a specific platform. For example:   constexpr bool is_a_test()Determines if the application is a test.   template \u003ctypename enum_type \u003e constexpr auto value(enum_type p_enum_value)Helper function to convert an enum to its integral value.   template \u003csize_t bit_field_width\u003e consteval uint32_t generate_field_of_ones()Generate a mask of 1s at compiletime.   template \u003cstd::integral T,size_t source_width,std::integral U\u003e constexpr static T increase_bit_depth(U p_value)Take a value of arbitrary bit resolution and create a value with scaled up the bit resolution.   template \u003cstd::unsigned_integral T,std::unsigned_integral U\u003e auto operator*(U p_value, full_scale\u003c T \u003e p_scale)Scale an integral value by a full_scalevalue.    Attributes     Name     constexpr const std::string_view platform_string The platform string determines which platform this application was built for. Use this to determine at compile or runtime if the running application is a “test”, an “lpc40” series mcu, and “stm” series mcu or a raspberry pi (“rpi”).   constexpr bool invalid_option Helper definition to simplify the usage of invalid_option_t.    Types Documentation enum pin_resistor    Enumerator Value Description     none 0 No pull up. This will cause the pin to float. This may be desirable if the pin has an external resistor attached or if the signal is sensitive to external devices like resistors.   pull_down  Pull the pin down to devices GND. This will ensure that the voltage read by the pin when there is no signal on the pin is LOW (or false).   pull_up  See pull down explanation, but in this case the pin is pulled up to VCC, also called VDD on some systems.    Set of possible pin mode resistor settings.\nSee each enumeration to get more details about when and how these should be used.\nFunctions Documentation function is_platform constexpr bool is_platform( std::string_view p_platform ) Determines if the current application was built for a specific platform. For example:\nParameters:\n p_platform platform string pattern to check against  Return:\n true matches the platform string false does not matches the platform string  embed::is_platform(“lpc4078”);\nWill return true if the PLATFORM macro defined at compile time was equal to lpc4078. If the developer wants to be less specific, let say, to just determine if the platform is in the lpc40xx family then the following example will work.\nembed::is_platform(“lpc40”);\nfunction is_a_test constexpr bool is_a_test() Determines if the application is a test.\nReturn:\n true this application is a test false this application is not a test  function value template \u003ctypename enum_type \u003e constexpr auto value( enum_type p_enum_value ) Helper function to convert an enum to its integral value.\nParameters:\n p_enum_value the enumeration you want to convert into an integral value  Template Parameters:\n enum_type the underlying type of the enumeration. Do not supply this value, it is inferred by the enum_value passed to the function.  Return: constexpr auto return the integral value of the enum.\nfunction generate_field_of_ones template \u003csize_t bit_field_width\u003e static consteval uint32_t generate_field_of_ones() Generate a mask of 1s at compiletime.\nTemplate Parameters:\n bit_field_width number of 1s in the mask  Return: consteval uint32_t mask with 1s at the LSB\nfunction increase_bit_depth template \u003cstd::integral T, size_t source_width, std::integral U\u003e static constexpr static T increase_bit_depth( U p_value ) Take a value of arbitrary bit resolution and create a value with scaled up the bit resolution.\nParameters:\n p_value the value to be scaled  Template Parameters:\n T integral type to bring the resolution of U up to. source_width the bit resolution of the input value U integral type of the input value  Return: constexpr T p_value but with resolution scaled up to type T\nThe purpose of bit scaling a value is to take a value of lower bit resolution, scale it up but keep the percentage relative to the bits resolution. This is useful for bit resolution erasure as well as image upscaling.\nFor example, lets take an 8-bit value of 127 (or 0x7F). This value is 50% of an 8-bit number. 50% of an 32-bit would be 2147483647 or 0x7FFFFFFF which is half of 2^32. A perfect upscaling would take 0x7F and generate 0x7FFFFFFF in this case. Doing so is quite costly and requires multiplication and division operations which are slower opetation.\nFast and efficient bit scaling is done via bit replication. For example, to scale an 8-bit value up to 32-bits would look like this:\n8-bit [ 0x7F ] |\\\\\\_____________________ | \\\\___________ \\ | \\____ \\ \\ | \\ \\ | | | | | V V V V 32-bit [ 0x7F ] [ 0x7F ] [ 0x7F ] [ 0x7F ] Expected 32-bit value is: 0x7FFFFFFF Actual value from scaling: 0x7F7F7F7F % difference is: (0x7FFFFFFF - 0x7F7F7F7F) / 0x7FFFFFFF = 0.39215684% A precent difference well below 1% makes this a viable solution for most applications.\nfunction operator* template \u003cstd::unsigned_integral T, std::unsigned_integral U\u003e auto operator*( U p_value, full_scale\u003c T \u003e p_scale ) Scale an integral value by a full_scalevalue.\nParameters:\n p_value value to be scaled p_scale value scalar  Template Parameters:\n T underlying type of the full scale value U type of the integral value to be scaled  Return: auto the scaled down result of p_value * p_scale.\nReturns a scaled down version of the input value. For example if the input is 100 and the scale value represents a percentage of 50%, then performing the following operation: 100 * full_scale_50_percent is equivalent to 100 * 0.5f.\nAttributes Documentation variable platform_string constexpr const std::string_view platform_string = PLATFORM_STRING; The platform string determines which platform this application was built for. Use this to determine at compile or runtime if the running application is a “test”, an “lpc40” series mcu, and “stm” series mcu or a raspberry pi (“rpi”).\nvariable invalid_option constexpr bool invalid_option = invalid_option_t\u003coptions...\u003e::value; Helper definition to simplify the usage of invalid_option_t.\nTemplate Parameters:\n options ignored by the application but needed to create a non-trivial specialization of this class which allows its usage in static_assert.   Updated on 2021-12-10 at 15:52:40 +0000\n","description":"","tags":null,"title":"embed","uri":"/libembeddedhal/api/namespaces/namespaceembed/"},{"content":"embed::adc Class Reference\nAnalog to Digital Converter (ADC) hardware abstraction interface. More…\n#include \u003cadc.hpp\u003e\nInherits from embed::driver\u003c\u003e\nAdditional inherited members Public Functions inherited from embed::driver\u003c\u003e\n    Name     bool initialize()Initialize the driver, apply the setting as defined in the settings_t structure and enable it. Calling this function after it has already been initialized will return false. In order to run initialization again, reset() must be called. After initialization, the settings are committed and saved into another settings structure. This settings can be looked up and inspected by the application.   void reset()Reset the driver in order to run initialize again. This is helpful if the application needs to change the settings of a driver after it is first initialized, like baud rate for serial or pull resistor for a pin.   bool is_initialized() constDetermine if the driver has been initialized.   settings_t \u0026 settings()Get access to uncommitted driver settings.   const settings_t \u0026 initialized_settings() constGet access to the settings that were used in the latest initialization. These settings only get updated when a successful initialize() has occurred.    Protected Functions inherited from embed::driver\u003c\u003e\n    Name     virtual bool driver_initialize() =0Implementation of driver initialize by the inherited driver.    Protected Attributes inherited from embed::driver\u003c\u003e\n    Name     settings_t m_settings Mutable settings.   settings_t m_initialized_settings Saved version of the settings at initialization.   bool m_initialized Determines if the driver has been initialized.    Detailed Description class embed::adc; Analog to Digital Converter (ADC) hardware abstraction interface.\nUse this interface for devices and peripherals that can convert analog voltage signals into a digital number.\n Updated on 2021-12-10 at 15:52:40 +0000\n","description":"","tags":null,"title":"embed::adc","uri":"/libembeddedhal/api/classes/classembed_1_1adc/"},{"content":"embed::bit_depth Struct Reference\nA type based on bit width that contains a value. More…\n#include \u003cfull_scale.hpp\u003e\nPublic Functions     Name     constexpr bit_depth(T p_value)construct bit_depth object    Public Attributes     Name     T value Value of the data at the bit width.    Detailed Description template \u003cstd::integral T, size_t bit_width\u003e struct embed::bit_depth; A type based on bit width that contains a value.\nTemplate Parameters:\n T the underlying type of the value bit_width the number of bits of the value  Public Functions Documentation function bit_depth inline constexpr bit_depth( T p_value ) construct bit_depth object\nParameters:\n p_value a integral value within the size of the bit_width. If the object is outside the bounds of the bit width, it is clamped.  Public Attributes Documentation variable value T value = 0; Value of the data at the bit width.\n Updated on 2021-12-10 at 15:52:40 +0000\n","description":"","tags":null,"title":"embed::bit_depth","uri":"/libembeddedhal/api/classes/structembed_1_1bit__depth/"},{"content":"embed::bit_limits Class Reference\nMore…\n#include \u003cfull_scale.hpp\u003e\nPublic Functions     Name     constexpr int_t max()Get the maximum value available for an integer of bit_width size and that can be stored within int_t.   constexpr int_t min()Get the minimum value available for an integer of bit_width size and that can be stored within int_t.    Detailed Description template \u003cuint8_t bit_width, std::integral int_t\u003e class embed::bit_limits; Template Parameters:\n bit_width int_t  Public Functions Documentation function max static inline constexpr int_t max() Get the maximum value available for an integer of bit_width size and that can be stored within int_t.\nReturn: constexpr int_t maximum value\nThe final value of the function depends also on the sign of the int type.\nfunction min static inline constexpr int_t min() Get the minimum value available for an integer of bit_width size and that can be stored within int_t.\nReturn: constexpr int_t minimum value\nThe final value of the function depends also on the sign of the int type. Unsigned ints simply return zero.\n Updated on 2021-12-10 at 15:52:40 +0000\n","description":"","tags":null,"title":"embed::bit_limits","uri":"/libembeddedhal/api/classes/classembed_1_1bit__limits/"},{"content":"embed::can Class Reference\nController Area Network (CAN bus) hardware abstraction interface.\n#include \u003ccan.hpp\u003e\nInherits from embed::driver\u003c can_settings \u003e\nPublic Classes     Name     struct message_t Attributes of a can message.    Public Types     Name     using uint32_t id_t Can message ID type trait.    Public Functions     Name     virtual void send(const message_t \u0026 p_message) =0Send a can message over the can bus.   virtual bool has_data() =0Determine if the can bus has any queued up can messages.   virtual message_t receive() =0Receieve a message from the can bus if one is available.   virtual void attach_interrupt(std::function\u003c void(can \u0026p_can)\u003e p_receive_handler) =0Setup driver to execute callback when a can message is received.    Additional inherited members Public Functions inherited from embed::driver\u003c can_settings \u003e\n    Name     bool initialize()Initialize the driver, apply the setting as defined in the settings_t structure and enable it. Calling this function after it has already been initialized will return false. In order to run initialization again, reset() must be called. After initialization, the settings are committed and saved into another settings structure. This settings can be looked up and inspected by the application.   void reset()Reset the driver in order to run initialize again. This is helpful if the application needs to change the settings of a driver after it is first initialized, like baud rate for serial or pull resistor for a pin.   bool is_initialized() constDetermine if the driver has been initialized.   settings_t \u0026 settings()Get access to uncommitted driver settings.   const settings_t \u0026 initialized_settings() constGet access to the settings that were used in the latest initialization. These settings only get updated when a successful initialize() has occurred.    Protected Functions inherited from embed::driver\u003c can_settings \u003e\n    Name     virtual bool driver_initialize() =0Implementation of driver initialize by the inherited driver.    Protected Attributes inherited from embed::driver\u003c can_settings \u003e\n    Name     settings_t m_settings Mutable settings.   settings_t m_initialized_settings Saved version of the settings at initialization.   bool m_initialized Determines if the driver has been initialized.    Public Types Documentation using id_t using embed::can::id_t = uint32_t; Can message ID type trait.\nPublic Functions Documentation function send virtual void send( const message_t \u0026 p_message ) =0 Send a can message over the can bus.\nParameters:\n p_message the message to be sent  function has_data virtual bool has_data() =0 Determine if the can bus has any queued up can messages.\nReturn:\n true a can message is available to be read false no messages available to be read  function receive virtual message_t receive() =0 Receieve a message from the can bus if one is available.\nReturn: message_t can message from the bus\nBehavior is undefined if no data is available.\nfunction attach_interrupt virtual void attach_interrupt( std::function\u003c void(can \u0026p_can)\u003e p_receive_handler ) =0 Setup driver to execute callback when a can message is received.\nParameters:\n p_receive_handler - can message reception callback. Set to nullptr to disable receive interrupts.   Updated on 2021-12-10 at 15:52:40 +0000\n","description":"","tags":null,"title":"embed::can","uri":"/libembeddedhal/api/classes/classembed_1_1can/"},{"content":"embed::can::message_t Struct Reference\nAttributes of a can message.\n#include \u003ccan.hpp\u003e\nPublic Attributes     Name     id_t id ID of the message.   uint8_t length The number of elements in the payload.   std::array\u003c uint8_t, 8 \u003e payload The message data.   bool is_remote_request    Public Attributes Documentation variable id id_t id; ID of the message.\nvariable length uint8_t length = 0; The number of elements in the payload.\nvariable payload std::array\u003c uint8_t, 8 \u003e payload { 0 }; The message data.\nvariable is_remote_request bool is_remote_request = false; Whether or not the message is a remote request frame. If true, then length and payload are ignored.\n Updated on 2021-12-10 at 15:52:40 +0000\n","description":"","tags":null,"title":"embed::can::message_t","uri":"/libembeddedhal/api/classes/structembed_1_1can_1_1message__t/"},{"content":"embed::can_network Class Reference\ncan_network is a canbus message receiver handler and More…\n#include \u003ccan_network.hpp\u003e\nInherits from embed::driver\u003c\u003e\nPublic Classes     Name     class node_t A can network node stores the can messages in a lock free way.    Public Functions     Name      can_network(can \u0026 p_can, std::pmr::memory_resource \u0026 p_memory_resource)Construct a new can network object.   virtual bool driver_initialize() overrideImplementation of driver initialize by the inherited driver.   node_t * register_message_id(can::id_t p_id)Assocate a can id with a node in the can network.   void manually_call_receive_handler()Manually call the receive handler.   can \u0026 bus()get a reference to the can peripheral driver   const auto \u0026 get_internal_map()Get the Internal Map object.    Additional inherited members Public Functions inherited from embed::driver\u003c\u003e\n    Name     bool initialize()Initialize the driver, apply the setting as defined in the settings_t structure and enable it. Calling this function after it has already been initialized will return false. In order to run initialization again, reset() must be called. After initialization, the settings are committed and saved into another settings structure. This settings can be looked up and inspected by the application.   void reset()Reset the driver in order to run initialize again. This is helpful if the application needs to change the settings of a driver after it is first initialized, like baud rate for serial or pull resistor for a pin.   bool is_initialized() constDetermine if the driver has been initialized.   settings_t \u0026 settings()Get access to uncommitted driver settings.   const settings_t \u0026 initialized_settings() constGet access to the settings that were used in the latest initialization. These settings only get updated when a successful initialize() has occurred.    Protected Attributes inherited from embed::driver\u003c\u003e\n    Name     settings_t m_settings Mutable settings.   settings_t m_initialized_settings Saved version of the settings at initialization.   bool m_initialized Determines if the driver has been initialized.    Detailed Description class embed::can_network; can_network is a canbus message receiver handler and\nManage, store, and organize messages received on the can bus.\nDrivers use this can bus peripheral manager rather than can directly. This is to ensure that the correct can messages are filtered to the correct driver.\nTo understand the importance of using this class over can direction consider protocols like UART and I2C. UART is asynchronous and communicates with a single device. Messages may come at an arbitrary time, but their origin is always known. Typically a single device driver holds control over a UART peripheral. I2C is a multi device us but the controller is always the initiator of the communication. Once an i2c controller successfully starts a conversation with another device on the bus, the response should always come from that device. CAN has this problem where messages can come in at any time from any device on the bus, making writting a driver that accepts the can interface directly impossible as there would be no way to coordinate which driver gets what data when the can interface has only a singular receive method.\nCan Network provides a means for routing messages based on ID to can device drivers.\nPublic Functions Documentation function can_network inline can_network( can \u0026 p_can, std::pmr::memory_resource \u0026 p_memory_resource ) Construct a new can network object.\nParameters:\n p_can can peripheral to manage the network of p_memory_resource memory resource used for storing can messages  function driver_initialize inline virtual bool driver_initialize() override Implementation of driver initialize by the inherited driver.\nReturn:\n true driver initialized successfully false driver initialization failed  Reimplements: embed::driver::driver_initialize\nfunction register_message_id inline node_t * register_message_id( can::id_t p_id ) Assocate a can id with a node in the can network.\nParameters:\n p_id - Associated ID of messages to be stored.  Exceptions:\n std::bad_alloc if this static storage allocated for this object is not enough to hold  Return: node_t* - reference to the CANBUS network node_t which can be used at anytime to retreive the latest received message from the CANBUS that is associated with the set ID.\nTo store can message with an associated ID in the can_network, it must be declared using this method. For example if you expect to get the following IDs 0x140, 0x7AA, and 0x561 from the CAN bus, then this method must be called as such:\n{C++} node_t* motor_node = can_network.register_message_id(0x140); node_t* encoder_node = can_network.register_message_id(0x561); node_t* temperature_node = can_network.register_message_id(0x7AA); function manually_call_receive_handler inline void manually_call_receive_handler() Manually call the receive handler.\nThis is useful for unit testing and for CANBUS peripherals that do NOT have a receive message interrupt routine. In the later case, a software (potentially a thread) can perform the receive call manually to extract messages from the CAN peripheral FIFO. This method cannot guarantee that data is not lost if the FIFO fills up.\nfunction bus inline can \u0026 bus() get a reference to the can peripheral driver\nReturn: can\u0026 reference to the can peripheral driver\nCan be used to initialize, configure, and enable the peripheral as well as transmit messages.\nfunction get_internal_map inline const auto \u0026 get_internal_map() Get the Internal Map object.\nReturn: const auto\u0026 map of all of the messages in the network.\nMeant for testing purposes or when direct inspection of the map is useful in userspace. Should not be used in by libraries.\n Updated on 2021-12-10 at 15:52:40 +0000\n","description":"","tags":null,"title":"embed::can_network","uri":"/libembeddedhal/api/classes/classembed_1_1can__network/"},{"content":"embed::can_network::node_t Class Reference\nA can network node stores the can messages in a lock free way. More…\n#include \u003ccan_network.hpp\u003e\nPublic Functions     Name      node_t()Construct a new node t object.   node_t \u0026 operator=(const node_t \u0026 p_node)Node assignment operator.    node_t(const node_t \u0026 p_node)Construct a new node t object.   can::message_t secure_get()Get this node’s can message.    Detailed Description class embed::can_network::node_t; A can network node stores the can messages in a lock free way.\nUpdating the can message data is completely lock free. Retrieving data uses atomics to poll for when the update() function has completed. This asymmetry in locking is to reduce write time, which is usually done in an interrupt context, rather than than read time, which is performed by a driver in a thread or main thread.\nPublic Functions Documentation function node_t inline node_t() Construct a new node t object.\nfunction operator= inline node_t \u0026 operator=( const node_t \u0026 p_node ) Node assignment operator.\nParameters:\n p_node the node copy  Return: node_t\u0026 reference to this object\nfunction node_t inline node_t( const node_t \u0026 p_node ) Construct a new node t object.\nParameters:\n p_node the object to copy  function secure_get inline can::message_t secure_get() Get this node’s can message.\nReturn: can::message_t\n Updated on 2021-12-10 at 15:52:40 +0000\n","description":"","tags":null,"title":"embed::can_network::node_t","uri":"/libembeddedhal/api/classes/classembed_1_1can__network_1_1node__t/"},{"content":"embed::can_settings Struct Reference\nGeneric settings for a can peripheral.\n#include \u003ccan.hpp\u003e\nPublic Attributes     Name     uint32_t clock_rate_hz Bus clock rate.    Public Attributes Documentation variable clock_rate_hz uint32_t clock_rate_hz = 100'000; Bus clock rate.\n Updated on 2021-12-10 at 15:52:40 +0000\n","description":"","tags":null,"title":"embed::can_settings","uri":"/libembeddedhal/api/classes/structembed_1_1can__settings/"},{"content":"embed::counter Class Reference\nCounter hardware abstraction interface. Use this interface for devices and peripherals that have counting capabilities. Such devices can count up or down. Useful for keeping time. Expect counters to overflow when they reach the end of counting register’s limits.\n#include \u003ccounter.hpp\u003e\nInherits from embed::driver\u003c\u003e\nPublic Types     Name     enum class controls { start, stop, reset}Set of controls for a counter.    Public Functions     Name     virtual bool is_running() =0Determine if the counter is currently running.   virtual void control(controls p_control) =0Control the state of the counter.   virtual void period(std::chrono::nanoseconds p_period) =0Period for each count of the timer. For example a period of 1ms and a count of 500 would mean that 500ms has elapse since the counter has been started.   virtual std::chrono::nanoseconds period() =0Get the current period for the counter.   virtual uint64_t count() =0Get the count of the counter.    Additional inherited members Public Functions inherited from embed::driver\u003c\u003e\n    Name     bool initialize()Initialize the driver, apply the setting as defined in the settings_t structure and enable it. Calling this function after it has already been initialized will return false. In order to run initialization again, reset() must be called. After initialization, the settings are committed and saved into another settings structure. This settings can be looked up and inspected by the application.   void reset()Reset the driver in order to run initialize again. This is helpful if the application needs to change the settings of a driver after it is first initialized, like baud rate for serial or pull resistor for a pin.   bool is_initialized() constDetermine if the driver has been initialized.   settings_t \u0026 settings()Get access to uncommitted driver settings.   const settings_t \u0026 initialized_settings() constGet access to the settings that were used in the latest initialization. These settings only get updated when a successful initialize() has occurred.    Protected Functions inherited from embed::driver\u003c\u003e\n    Name     virtual bool driver_initialize() =0Implementation of driver initialize by the inherited driver.    Protected Attributes inherited from embed::driver\u003c\u003e\n    Name     settings_t m_settings Mutable settings.   settings_t m_initialized_settings Saved version of the settings at initialization.   bool m_initialized Determines if the driver has been initialized.    Public Types Documentation enum controls    Enumerator Value Description     start  Control value to start the counter.   stop  Control value to stop a counter.   reset  Control value to reset a counter. The counter shall remain in a running or stopped state after this call. So an ongoing counter will continue to count but will have its counter reset to zero if this control is used. If a counter is stopped, then it shall be reset to zero, and stay stopped.    Set of controls for a counter.\nPublic Functions Documentation function is_running virtual bool is_running() =0 Determine if the counter is currently running.\nReturn:\n true counter is currently running false counter is currently stopped  function control virtual void control( controls p_control ) =0 Control the state of the counter.\nParameters:\n p_control new state for the counter  function period virtual void period( std::chrono::nanoseconds p_period ) =0 Period for each count of the timer. For example a period of 1ms and a count of 500 would mean that 500ms has elapse since the counter has been started.\nParameters:\n p_period the amount of time each count should be.  function period virtual std::chrono::nanoseconds period() =0 Get the current period for the counter.\nReturn: std::chrono::nanoseconds\nfunction count virtual uint64_t count() =0 Get the count of the counter.\nReturn: uint64_t current count\n Updated on 2021-12-10 at 15:52:40 +0000\n","description":"","tags":null,"title":"embed::counter","uri":"/libembeddedhal/api/classes/classembed_1_1counter/"},{"content":"embed::dac Class Reference\nDigital to Analog Converter (DAC) hardware abstraction interface. More…\n#include \u003cdac.hpp\u003e\nInherits from embed::driver\u003c\u003e\nPublic Functions     Name     virtual void write(full_scale\u003c uint32_t \u003e p_value) =0Generate a voltage between a defined LOW and HIGH voltage.    Additional inherited members Public Functions inherited from embed::driver\u003c\u003e\n    Name     bool initialize()Initialize the driver, apply the setting as defined in the settings_t structure and enable it. Calling this function after it has already been initialized will return false. In order to run initialization again, reset() must be called. After initialization, the settings are committed and saved into another settings structure. This settings can be looked up and inspected by the application.   void reset()Reset the driver in order to run initialize again. This is helpful if the application needs to change the settings of a driver after it is first initialized, like baud rate for serial or pull resistor for a pin.   bool is_initialized() constDetermine if the driver has been initialized.   settings_t \u0026 settings()Get access to uncommitted driver settings.   const settings_t \u0026 initialized_settings() constGet access to the settings that were used in the latest initialization. These settings only get updated when a successful initialize() has occurred.    Protected Functions inherited from embed::driver\u003c\u003e\n    Name     virtual bool driver_initialize() =0Implementation of driver initialize by the inherited driver.    Protected Attributes inherited from embed::driver\u003c\u003e\n    Name     settings_t m_settings Mutable settings.   settings_t m_initialized_settings Saved version of the settings at initialization.   bool m_initialized Determines if the driver has been initialized.    Detailed Description class embed::dac; Digital to Analog Converter (DAC) hardware abstraction interface.\nUse this interface for devices and peripherals that can create arbitrary analog voltages between a defined LOW and HIGH voltage.\nPublic Functions Documentation function write virtual void write( full_scale\u003c uint32_t \u003e p_value ) =0 Generate a voltage between a defined LOW and HIGH voltage.\nParameters:\n p_value precentage scale from LOW to HIGH  The LOW and HIGH voltage are generally configured by a reference voltage (usually denoted V_ref) connected to the device. Generally though, the low voltage is 0V and the high voltage reference is VCC.\n Updated on 2021-12-10 at 15:52:40 +0000\n","description":"","tags":null,"title":"embed::dac","uri":"/libembeddedhal/api/classes/classembed_1_1dac/"},{"content":"embed::driver Class Reference\nThe basis class for all peripheral, device and system drivers in libembeddedhal. More…\n#include \u003cdriver.hpp\u003e\nInherited by embed::adc, embed::can_network, embed::counter, embed::dac, embed::pwm, embed::timer\nPublic Functions     Name     bool initialize()Initialize the driver, apply the setting as defined in the settings_t structure and enable it. Calling this function after it has already been initialized will return false. In order to run initialization again, reset() must be called. After initialization, the settings are committed and saved into another settings structure. This settings can be looked up and inspected by the application.   void reset()Reset the driver in order to run initialize again. This is helpful if the application needs to change the settings of a driver after it is first initialized, like baud rate for serial or pull resistor for a pin.   bool is_initialized() constDetermine if the driver has been initialized.   settings_t \u0026 settings()Get access to uncommitted driver settings.   const settings_t \u0026 initialized_settings() constGet access to the settings that were used in the latest initialization. These settings only get updated when a successful initialize() has occurred.    Protected Functions     Name     virtual bool driver_initialize() =0Implementation of driver initialize by the inherited driver.    Protected Attributes     Name     settings_t m_settings Mutable settings.   settings_t m_initialized_settings Saved version of the settings at initialization.   bool m_initialized Determines if the driver has been initialized.    Detailed Description template \u003cclass settings_t =no_settings\u003e class embed::driver; The basis class for all peripheral, device and system drivers in libembeddedhal.\nTemplate Parameters:\n settings_t generic settings for the driver. For example, generic settings for a uart driver would have baud rate, stop bits and parity. This is expected of all UART devices and as such is part of the systems API.  Public Functions Documentation function initialize inline bool initialize() Initialize the driver, apply the setting as defined in the settings_t structure and enable it. Calling this function after it has already been initialized will return false. In order to run initialization again, reset() must be called. After initialization, the settings are committed and saved into another settings structure. This settings can be looked up and inspected by the application.\nReturn:\n true - initialization of the driver was successful false - initialization of the driver failed. See the error() function for details about exactly what failed.  function reset inline void reset() Reset the driver in order to run initialize again. This is helpful if the application needs to change the settings of a driver after it is first initialized, like baud rate for serial or pull resistor for a pin.\nfunction is_initialized inline bool is_initialized() const Determine if the driver has been initialized.\nReturn:\n true the driver is initialized false the driver has not been initialized or has been reset  function settings inline settings_t \u0026 settings() Get access to uncommitted driver settings.\nReturn: settings_t\u0026 reference to the uncommitted driver settings. When initialize runs successful, the uncommitted settings will be saved to the initialize_settings().\nfunction initialized_settings inline const settings_t \u0026 initialized_settings() const Get access to the settings that were used in the latest initialization. These settings only get updated when a successful initialize() has occurred.\nReturn: const settings_t\u0026 the current settings of the driver if it is initialized. If the driver is not initialized, then the contents of this structure should be ignored as they may not represent the current of the driver.\nProtected Functions Documentation function driver_initialize virtual bool driver_initialize() =0 Implementation of driver initialize by the inherited driver.\nReturn:\n true driver initialized successfully false driver initialization failed  Reimplemented by: embed::can_network::driver_initialize\nProtected Attributes Documentation variable m_settings settings_t m_settings {}; Mutable settings.\nvariable m_initialized_settings settings_t m_initialized_settings {}; Saved version of the settings at initialization.\nvariable m_initialized bool m_initialized = false; Determines if the driver has been initialized.\n Updated on 2021-12-10 at 15:52:40 +0000\n","description":"","tags":null,"title":"embed::driver","uri":"/libembeddedhal/api/classes/classembed_1_1driver/"},{"content":"embed::full_scale Class Reference\nA bit resolution erased representation of a precentage value using only integral arithmetic. More…\n#include \u003cfull_scale.hpp\u003e\nPublic Functions     Name     constexpr full_scale()construct a full scale value with initial value zero.   template \u003ctypename U ,size_t bit_width\u003e constexpr full_scale\u003c T \u003e \u0026 operator=(bit_depth\u003c U, bit_width \u003e p_value)Construct a full_scale based on the bit_depth value.   template \u003ctypename U ,size_t bit_width\u003e constexpr full_scale(bit_depth\u003c U, bit_width \u003e p_value)Construct a full_scale based on the bit_depth value.   T value()Get internal integral value.    Public Attributes     Name     constexpr size_t bit_width Calculate the number.    Detailed Description template \u003ctypename T \u003e class embed::full_scale; A bit resolution erased representation of a precentage value using only integral arithmetic.\nTemplate Parameters:\n T the integral type to represent the percentage value (typically uint32_t or int32_t)  Public Functions Documentation function full_scale inline constexpr full_scale() construct a full scale value with initial value zero.\nfunction operator= template \u003ctypename U , size_t bit_width\u003e inline constexpr full_scale\u003c T \u003e \u0026 operator=( bit_depth\u003c U, bit_width \u003e p_value ) Construct a full_scale based on the bit_depth value.\nParameters:\n p_value the value at a specific bit resolution to scale up to a full scale value  Template Parameters:\n U type of the bit depth object bit_width the bit width of the object  Return: constexpr full_scale\u0026 reference to this object\nfunction full_scale template \u003ctypename U , size_t bit_width\u003e inline constexpr full_scale( bit_depth\u003c U, bit_width \u003e p_value ) Construct a full_scale based on the bit_depth value.\nParameters:\n p_value the bit depth object  Template Parameters:\n U type of the bit depth object bit_width the bit width of the object  function value inline T value() Get internal integral value.\nReturn: T full scale value\nPublic Attributes Documentation variable bit_width static constexpr size_t bit_width = sizeof(T) * CHAR_BIT; Calculate the number.\n Updated on 2021-12-10 at 15:52:40 +0000\n","description":"","tags":null,"title":"embed::full_scale","uri":"/libembeddedhal/api/classes/classembed_1_1full__scale/"},{"content":"embed::i2c Class Reference\nInter-integrated Circuit (I2C) or Two Wire Interface (TWI) communication protocol hardware abstract interface.\n#include \u003ci2c.hpp\u003e\nInherits from embed::driver\u003c i2c_settings \u003e\nPublic Functions     Name     virtual void transaction(std::byte p_address, std::span\u003c const std::byte \u003e p_data_out, std::span\u003c std::byte \u003e p_data_in) =0perform an i2c transaction with another device on the bus. The type of transaction depends on values of input parameters.   virtual bool busy() =0Determines if the i2c transaction is ongoing.    Additional inherited members Public Functions inherited from embed::driver\u003c i2c_settings \u003e\n    Name     bool initialize()Initialize the driver, apply the setting as defined in the settings_t structure and enable it. Calling this function after it has already been initialized will return false. In order to run initialization again, reset() must be called. After initialization, the settings are committed and saved into another settings structure. This settings can be looked up and inspected by the application.   void reset()Reset the driver in order to run initialize again. This is helpful if the application needs to change the settings of a driver after it is first initialized, like baud rate for serial or pull resistor for a pin.   bool is_initialized() constDetermine if the driver has been initialized.   settings_t \u0026 settings()Get access to uncommitted driver settings.   const settings_t \u0026 initialized_settings() constGet access to the settings that were used in the latest initialization. These settings only get updated when a successful initialize() has occurred.    Protected Functions inherited from embed::driver\u003c i2c_settings \u003e\n    Name     virtual bool driver_initialize() =0Implementation of driver initialize by the inherited driver.    Protected Attributes inherited from embed::driver\u003c i2c_settings \u003e\n    Name     settings_t m_settings Mutable settings.   settings_t m_initialized_settings Saved version of the settings at initialization.   bool m_initialized Determines if the driver has been initialized.    Public Functions Documentation function transaction virtual void transaction( std::byte p_address, std::span\u003c const std::byte \u003e p_data_out, std::span\u003c std::byte \u003e p_data_in ) =0 perform an i2c transaction with another device on the bus. The type of transaction depends on values of input parameters.\nParameters:\n p_address 7-bit address of the device you want to communicate with. To perform a transaction with a 10-bit address, this parameter must be the address upper byte of the 10-bit address OR’d with 0b1111'0000 (the 10-bit address indicator). The lower byte of the address must be contained in the first byte of the p_data_out span. p_data_out data to be written to the addressed device. Set to nullptr with length zero in order to skip writting. p_data_in buffer to store read data from the addressed device. Set to nullptr with length 0 in order to skip reading.  Performing Write, Read and Write-Then-Read transactions depends on which span for data_out and data_in are set to null.\n For write transactions, pass p_data_in as an empty span std::span\u003cstd::byte\u003e{} and pass a buffer to p_data_out. For read transactions, pass p_data_out as an empty span std::span\u003cconst std::byte\u003e{} and pass a buffer to p_data_in. For write-then-read transactions, pass a buffer for both p_data_in p_data_out. Implementations of transaction can be synchronous, interrupt driven or DMA driven. Calling transaction while a current transaction is ongoing is undefined behavior. To prevent this, poll busy() until it returns false.  function busy virtual bool busy() =0 Determines if the i2c transaction is ongoing.\nReturn:\n true transaction is currently ongoing false device is idle and available for a transaction   Updated on 2021-12-10 at 15:52:40 +0000\n","description":"","tags":null,"title":"embed::i2c","uri":"/libembeddedhal/api/classes/classembed_1_1i2c/"},{"content":"embed::i2c_settings Struct Reference\nGeneric settings for a standard I2C device.\n#include \u003ci2c.hpp\u003e\nPublic Attributes     Name     uint32_t clock_rate_hz The serial clock rate in hertz.    Public Attributes Documentation variable clock_rate_hz uint32_t clock_rate_hz = 100'000; The serial clock rate in hertz.\n Updated on 2021-12-10 at 15:52:40 +0000\n","description":"","tags":null,"title":"embed::i2c_settings","uri":"/libembeddedhal/api/classes/structembed_1_1i2c__settings/"},{"content":"embed::input_pin Class Reference\nDigital input pin hardware abstraction. More…\n#include \u003cgpio.hpp\u003e\nInherits from embed::driver\u003c input_pin_settings \u003e\nPublic Functions     Name     virtual bool level() const =0Read the state of the input pin.    Additional inherited members Public Functions inherited from embed::driver\u003c input_pin_settings \u003e\n    Name     bool initialize()Initialize the driver, apply the setting as defined in the settings_t structure and enable it. Calling this function after it has already been initialized will return false. In order to run initialization again, reset() must be called. After initialization, the settings are committed and saved into another settings structure. This settings can be looked up and inspected by the application.   void reset()Reset the driver in order to run initialize again. This is helpful if the application needs to change the settings of a driver after it is first initialized, like baud rate for serial or pull resistor for a pin.   bool is_initialized() constDetermine if the driver has been initialized.   settings_t \u0026 settings()Get access to uncommitted driver settings.   const settings_t \u0026 initialized_settings() constGet access to the settings that were used in the latest initialization. These settings only get updated when a successful initialize() has occurred.    Protected Functions inherited from embed::driver\u003c input_pin_settings \u003e\n    Name     virtual bool driver_initialize() =0Implementation of driver initialize by the inherited driver.    Protected Attributes inherited from embed::driver\u003c input_pin_settings \u003e\n    Name     settings_t m_settings Mutable settings.   settings_t m_initialized_settings Saved version of the settings at initialization.   bool m_initialized Determines if the driver has been initialized.    Detailed Description class embed::input_pin; Digital input pin hardware abstraction.\nUse this to read a pin and determine if the voltage on it is HIGH or LOW.\nPublic Functions Documentation function level virtual bool level() const =0 Read the state of the input pin.\nReturn:\n true indicates a HIGH voltage false indicates a LOW voltage   Updated on 2021-12-10 at 15:52:40 +0000\n","description":"","tags":null,"title":"embed::input_pin","uri":"/libembeddedhal/api/classes/classembed_1_1input__pin/"},{"content":"embed::input_pin_settings Struct Reference\nGeneric settings for input pins.\n#include \u003cgpio.hpp\u003e\nPublic Attributes     Name     pin_resistor resistor pull resistor for an input pin    Public Attributes Documentation variable resistor pin_resistor resistor = pin_resistor::pull_up; pull resistor for an input pin\n Updated on 2021-12-10 at 15:52:40 +0000\n","description":"","tags":null,"title":"embed::input_pin_settings","uri":"/libembeddedhal/api/classes/structembed_1_1input__pin__settings/"},{"content":"embed::interrupt_pin Class Reference\nDigital interrupt pin hardware abstraction. More…\n#include \u003cgpio.hpp\u003e\nInherits from embed::driver\u003c interrupt_pin_settings \u003e\nPublic Types     Name     enum class trigger_edge { falling = 0, rising = 1, both = 2}The condition in which an interrupt is triggered.    Public Functions     Name     virtual bool level() const =0Return the voltage level of the pin.   virtual void attach_interrupt(std::function\u003c void(void)\u003e p_callback, trigger_edge p_trigger) =0Enable interrupts for this pin. Pass in the callback to be executed when the trigger condition is met. This function can be called multiple times if the callback or trigger conditions need to be changed. detach_interrupts() does not need to be called before re-running this function.   virtual void detach_interrupt() =0Disable interrupts for this pin.    Additional inherited members Public Functions inherited from embed::driver\u003c interrupt_pin_settings \u003e\n    Name     bool initialize()Initialize the driver, apply the setting as defined in the settings_t structure and enable it. Calling this function after it has already been initialized will return false. In order to run initialization again, reset() must be called. After initialization, the settings are committed and saved into another settings structure. This settings can be looked up and inspected by the application.   void reset()Reset the driver in order to run initialize again. This is helpful if the application needs to change the settings of a driver after it is first initialized, like baud rate for serial or pull resistor for a pin.   bool is_initialized() constDetermine if the driver has been initialized.   settings_t \u0026 settings()Get access to uncommitted driver settings.   const settings_t \u0026 initialized_settings() constGet access to the settings that were used in the latest initialization. These settings only get updated when a successful initialize() has occurred.    Protected Functions inherited from embed::driver\u003c interrupt_pin_settings \u003e\n    Name     virtual bool driver_initialize() =0Implementation of driver initialize by the inherited driver.    Protected Attributes inherited from embed::driver\u003c interrupt_pin_settings \u003e\n    Name     settings_t m_settings Mutable settings.   settings_t m_initialized_settings Saved version of the settings at initialization.   bool m_initialized Determines if the driver has been initialized.    Detailed Description class embed::interrupt_pin; Digital interrupt pin hardware abstraction.\nUse this to trigger an interrupt service routine (ISR) when a pin detects a falling edge (when the pin’s voltage transitions from HIGH to LOW), a rising edge (when the pin’s voltage transitions from LOW to HIGH), or any transition of state on the pin.\nPublic Types Documentation enum trigger_edge    Enumerator Value Description     falling 0 Trigger and interrupt when a pin transitions from HIGH voltage to LOW voltage.   rising 1 Trigger and interrupt when a pin transitions from LOW voltage to HIGH voltage.   both 2 Trigger and interrupt when a pin transitions it state.    The condition in which an interrupt is triggered.\nPublic Functions Documentation function level virtual bool level() const =0 Return the voltage level of the pin.\nReturn:\n true HIGH voltage false LOW voltage  function attach_interrupt virtual void attach_interrupt( std::function\u003c void(void)\u003e p_callback, trigger_edge p_trigger ) =0 Enable interrupts for this pin. Pass in the callback to be executed when the trigger condition is met. This function can be called multiple times if the callback or trigger conditions need to be changed. detach_interrupts() does not need to be called before re-running this function.\nParameters:\n p_callback function to execute when the trigger condition is met p_trigger the trigger condition that will signal the system to run the callback.  function detach_interrupt virtual void detach_interrupt() =0 Disable interrupts for this pin.\n Updated on 2021-12-10 at 15:52:40 +0000\n","description":"","tags":null,"title":"embed::interrupt_pin","uri":"/libembeddedhal/api/classes/classembed_1_1interrupt__pin/"},{"content":"embed::interrupt_pin_settings Struct Reference\nGeneric settings for interrupt pins.\n#include \u003cgpio.hpp\u003e\nPublic Attributes     Name     pin_resistor resistor pull resistor for an interrupt pin. Generally advised to NOT use pin_resistor::none and if it is used and external pull resistor should be placed on the pin to prevent random interrupt from firing.    Public Attributes Documentation variable resistor pin_resistor resistor = pin_resistor::pull_up; pull resistor for an interrupt pin. Generally advised to NOT use pin_resistor::none and if it is used and external pull resistor should be placed on the pin to prevent random interrupt from firing.\n Updated on 2021-12-10 at 15:52:40 +0000\n","description":"","tags":null,"title":"embed::interrupt_pin_settings","uri":"/libembeddedhal/api/classes/structembed_1_1interrupt__pin__settings/"},{"content":"embed::invalid_option_t Struct Reference\nUsed for defining static_asserts that should always fail, but only if the static_assert line is hit via if constexpr control block. Prefer to NOT use this directly but to use invalid_option instead. More…\n#include \u003cdriver.hpp\u003e\nInherits from std::false_type\nDetailed Description template \u003cauto... options\u003e struct embed::invalid_option_t; Used for defining static_asserts that should always fail, but only if the static_assert line is hit via if constexpr control block. Prefer to NOT use this directly but to use invalid_option instead.\nTemplate Parameters:\n options ignored by the application but needed to create a non-trivial specialization of this class which allows its usage in static_assert.   Updated on 2021-12-10 at 15:52:40 +0000\n","description":"","tags":null,"title":"embed::invalid_option_t","uri":"/libembeddedhal/api/classes/structembed_1_1invalid__option__t/"},{"content":"embed::no_settings Struct Reference\nAn empty settings structure used to indicate that a driver or interface does not have generic settings.\n#include \u003cdriver.hpp\u003e\n Updated on 2021-12-10 at 15:52:40 +0000\n","description":"","tags":null,"title":"embed::no_settings","uri":"/libembeddedhal/api/classes/structembed_1_1no__settings/"},{"content":"embed::output_pin Class Reference\nDigital output pin hardware abstraction. More…\n#include \u003cgpio.hpp\u003e\nInherits from embed::driver\u003c output_pin_settings \u003e\nPublic Functions     Name     virtual void level(bool p_high) =0Set the state of the pin.   virtual bool level() const =0Read the state of the input pin. Implementations must read the pin state from hardware and will not simply cache the results from running level(bool).    Additional inherited members Public Functions inherited from embed::driver\u003c output_pin_settings \u003e\n    Name     bool initialize()Initialize the driver, apply the setting as defined in the settings_t structure and enable it. Calling this function after it has already been initialized will return false. In order to run initialization again, reset() must be called. After initialization, the settings are committed and saved into another settings structure. This settings can be looked up and inspected by the application.   void reset()Reset the driver in order to run initialize again. This is helpful if the application needs to change the settings of a driver after it is first initialized, like baud rate for serial or pull resistor for a pin.   bool is_initialized() constDetermine if the driver has been initialized.   settings_t \u0026 settings()Get access to uncommitted driver settings.   const settings_t \u0026 initialized_settings() constGet access to the settings that were used in the latest initialization. These settings only get updated when a successful initialize() has occurred.    Protected Functions inherited from embed::driver\u003c output_pin_settings \u003e\n    Name     virtual bool driver_initialize() =0Implementation of driver initialize by the inherited driver.    Protected Attributes inherited from embed::driver\u003c output_pin_settings \u003e\n    Name     settings_t m_settings Mutable settings.   settings_t m_initialized_settings Saved version of the settings at initialization.   bool m_initialized Determines if the driver has been initialized.    Detailed Description class embed::output_pin; Digital output pin hardware abstraction.\nUse this to drive a pin HIGH or LOW in order to send a control signal or turn off or on an LED.\nPublic Functions Documentation function level virtual void level( bool p_high ) =0 Set the state of the pin.\nParameters:\n p_high if true then the pin state is set to HIGH voltage. If false, the pin state is set to LOW voltage.  function level virtual bool level() const =0 Read the state of the input pin. Implementations must read the pin state from hardware and will not simply cache the results from running level(bool).\nReturn:\n true indicates a HIGH voltage false indicates a LOW voltage   Updated on 2021-12-10 at 15:52:40 +0000\n","description":"","tags":null,"title":"embed::output_pin","uri":"/libembeddedhal/api/classes/classembed_1_1output__pin/"},{"content":"embed::output_pin_settings Struct Reference\nGeneric settings for output pins.\n#include \u003cgpio.hpp\u003e\nPublic Attributes     Name     bool starting_level Set the starting level of the output pin on initialization. HIGH voltage defined as true and LOW voltage defined as false.   bool open_drain Starting level of the output pin. HIGH voltage defined as true and LOW voltage defined as false.   pin_resistor resistor Pull resistor for the pin. This generally only helpful when open drain is enabled.    Public Attributes Documentation variable starting_level bool starting_level = true; Set the starting level of the output pin on initialization. HIGH voltage defined as true and LOW voltage defined as false.\nvariable open_drain bool open_drain = false; Starting level of the output pin. HIGH voltage defined as true and LOW voltage defined as false.\nvariable resistor pin_resistor resistor = pin_resistor::pull_up; Pull resistor for the pin. This generally only helpful when open drain is enabled.\n Updated on 2021-12-10 at 15:52:40 +0000\n","description":"","tags":null,"title":"embed::output_pin_settings","uri":"/libembeddedhal/api/classes/structembed_1_1output__pin__settings/"},{"content":"embed::pwm Class Reference\nPulse Width Modulation (PWM) channel hardware abstraction.\n#include \u003cpwm.hpp\u003e\nInherits from embed::driver\u003c\u003e\nAdditional inherited members Public Functions inherited from embed::driver\u003c\u003e\n    Name     bool initialize()Initialize the driver, apply the setting as defined in the settings_t structure and enable it. Calling this function after it has already been initialized will return false. In order to run initialization again, reset() must be called. After initialization, the settings are committed and saved into another settings structure. This settings can be looked up and inspected by the application.   void reset()Reset the driver in order to run initialize again. This is helpful if the application needs to change the settings of a driver after it is first initialized, like baud rate for serial or pull resistor for a pin.   bool is_initialized() constDetermine if the driver has been initialized.   settings_t \u0026 settings()Get access to uncommitted driver settings.   const settings_t \u0026 initialized_settings() constGet access to the settings that were used in the latest initialization. These settings only get updated when a successful initialize() has occurred.    Protected Functions inherited from embed::driver\u003c\u003e\n    Name     virtual bool driver_initialize() =0Implementation of driver initialize by the inherited driver.    Protected Attributes inherited from embed::driver\u003c\u003e\n    Name     settings_t m_settings Mutable settings.   settings_t m_initialized_settings Saved version of the settings at initialization.   bool m_initialized Determines if the driver has been initialized.     Updated on 2021-12-10 at 15:52:40 +0000\n","description":"","tags":null,"title":"embed::pwm","uri":"/libembeddedhal/api/classes/classembed_1_1pwm/"},{"content":"embed::serial Class Reference\nSerial communication protocol hardware abstract interface. More…\n#include \u003cserial.hpp\u003e\nInherits from embed::driver\u003c serial_settings \u003e\nPublic Functions     Name     virtual void write(std::span\u003c const std::byte \u003e p_data) =0Write data on the transmitter line of the port. The exact implementation for this can be polling, interrupt driven or DMA driven. There is no guarantee on exactly how a write operation will operate, thus the busy() function must polled called after this returns to determine if the write operation has finished. Attempting to call write() when tranmission is busy is undefined behavior.   virtual bool busy() =0Determines if the write operation is currently on going.   virtual size_t bytes_available() =0The number of bytes that have been buffered. For frames less than 8-bits, each byte holds a frame. For frames above 8-bits the number of bytes returned indicates the number of bytes a buffer needs to be to return all of the data held in the buffer.   virtual std::span\u003c const std::byte \u003e read(std::span\u003c std::byte \u003e p_data) =0Read the bytes received over the ports receiver line and stored in the serial implementations buffer. The number of bytes read will subtract the number of bytes available until it reaches zero.   virtual void flush() =0Set bytes_available() to zero and clear any received data stored in hardware registers. This operation must be faster than simply running read() until bytes_available() is empty.    Additional inherited members Public Functions inherited from embed::driver\u003c serial_settings \u003e\n    Name     bool initialize()Initialize the driver, apply the setting as defined in the settings_t structure and enable it. Calling this function after it has already been initialized will return false. In order to run initialization again, reset() must be called. After initialization, the settings are committed and saved into another settings structure. This settings can be looked up and inspected by the application.   void reset()Reset the driver in order to run initialize again. This is helpful if the application needs to change the settings of a driver after it is first initialized, like baud rate for serial or pull resistor for a pin.   bool is_initialized() constDetermine if the driver has been initialized.   settings_t \u0026 settings()Get access to uncommitted driver settings.   const settings_t \u0026 initialized_settings() constGet access to the settings that were used in the latest initialization. These settings only get updated when a successful initialize() has occurred.    Protected Functions inherited from embed::driver\u003c serial_settings \u003e\n    Name     virtual bool driver_initialize() =0Implementation of driver initialize by the inherited driver.    Protected Attributes inherited from embed::driver\u003c serial_settings \u003e\n    Name     settings_t m_settings Mutable settings.   settings_t m_initialized_settings Saved version of the settings at initialization.   bool m_initialized Determines if the driver has been initialized.    Detailed Description class embed::serial; Serial communication protocol hardware abstract interface.\nUse this interface for hardware that implements a serial protocol like UART, RS232, RS485 and many others that use a similar communication protocol but may use different voltage schemes.\nDue to the asynchronous nature of serial communication protocols, all implementations of serial devices MUST buffer received bytes using DMA or interrupts. A thread should not be used as this generally greatly increases the ROM and RAM cost of using library.\nAll implementations MUST allow the user to supply their own buffer of arbitrary size, such that the amount of buffered data can be tailored to the needs of the application.\nPublic Functions Documentation function write virtual void write( std::span\u003c const std::byte \u003e p_data ) =0 Write data on the transmitter line of the port. The exact implementation for this can be polling, interrupt driven or DMA driven. There is no guarantee on exactly how a write operation will operate, thus the busy() function must polled called after this returns to determine if the write operation has finished. Attempting to call write() when tranmission is busy is undefined behavior.\nParameters:\n p_data data to be transmitted over the serial port transmitter line  Data frames are not compact when frame size is less than 8 bits. Meaning that, if you want to send three 5-bit frames, then you will need to use a span of at least 3 bytes to hold each value.\nWhen writing data with frame size greater than 8 is in little endian order. Meaning that the first byte in the sequence is the lower byte and the next is the greater byte. If you wanted to send a 9-bit frame with value 0x14A, the first byte must be 0x4A and the next 0x01.\nfunction busy virtual bool busy() =0 Determines if the write operation is currently on going.\nReturn:\n true serial transmitter is currently writing data to the port false serial transmitter is idle and available to write data  function bytes_available virtual size_t bytes_available() =0 The number of bytes that have been buffered. For frames less than 8-bits, each byte holds a frame. For frames above 8-bits the number of bytes returned indicates the number of bytes a buffer needs to be to return all of the data held in the buffer.\nReturn: size_t number of buffered by the serial driver and are available to be read by the read() function.\nfunction read virtual std::span\u003c const std::byte \u003e read( std::span\u003c std::byte \u003e p_data ) =0 Read the bytes received over the ports receiver line and stored in the serial implementations buffer. The number of bytes read will subtract the number of bytes available until it reaches zero.\nParameters:\n p_data Buffer to read bytes back from. If the length of this buffer is greater than the value returned by bytes_available() then buffer is filled up to the length returned by bytes_available(). The rest of the buffer is left untouched.  Return: std::spanprovides a means to get the length of bytes read into the buffer p_data. The address will ALWAYS be the same as p_data and the length will be equal to the number of bytes read from the buffer.\nfunction flush virtual void flush() =0 Set bytes_available() to zero and clear any received data stored in hardware registers. This operation must be faster than simply running read() until bytes_available() is empty.\n Updated on 2021-12-10 at 15:52:40 +0000\n","description":"","tags":null,"title":"embed::serial","uri":"/libembeddedhal/api/classes/classembed_1_1serial/"},{"content":"embed::serial_settings Struct Reference\nGeneric settings for a standard serial device.\n#include \u003cserial.hpp\u003e\nPublic Types     Name     enum class uint8_t stop_bits { one = 0, two}Set of available stop bits options.   enum class uint8_t parity { none = 0, odd, even, forced1, forced0}Set of parity bit options.    Public Attributes     Name     uint32_t baud_rate The operating speed of the baud rate (in units of bits per second)   parity parity Parity bit type for each frame.   stop_bits stop Number of stop bits for each frame.   uint8_t frame_size Number of bits in each frame. Typically between 5 to 9.    Public Types Documentation enum stop_bits    Enumerator Value Description     one 0    two      Set of available stop bits options.\nenum parity    Enumerator Value Description     none 0 Disable parity bit as part of the frame.   odd  Enable parity and set 1 (HIGH) when the number of bits is odd.   even  Enable parity and set 1 (HIGH) when the number of bits is even.   forced1  Enable parity bit and always return 1 (HIGH) for ever frame.   forced0  Enable parity bit and always return 0 (LOW) for ever frame.    Set of parity bit options.\nPublic Attributes Documentation variable baud_rate uint32_t baud_rate = 115200; The operating speed of the baud rate (in units of bits per second)\nvariable parity parity parity = parity::none; Parity bit type for each frame.\nvariable stop stop_bits stop = stop_bits::one; Number of stop bits for each frame.\nvariable frame_size uint8_t frame_size = 8; Number of bits in each frame. Typically between 5 to 9.\n Updated on 2021-12-10 at 15:52:40 +0000\n","description":"","tags":null,"title":"embed::serial_settings","uri":"/libembeddedhal/api/classes/structembed_1_1serial__settings/"},{"content":"embed::spi Class Reference\nSerial peripheral interface (SPI) communication protocol hardware abstract interface.\n#include \u003cspi.hpp\u003e\nInherits from embed::driver\u003c spi_settings \u003e\nPublic Functions     Name     virtual bool busy() =0Determines if a transfer is currently ongoing.   virtual void transfer(std::span\u003c const std::byte \u003e p_data_out, std::span\u003c std::byte \u003e p_data_in, std::byte p_write_value =std::byte{ 0xFF }) =0Send and receieve bytes from the spi bus.    Additional inherited members Public Functions inherited from embed::driver\u003c spi_settings \u003e\n    Name     bool initialize()Initialize the driver, apply the setting as defined in the settings_t structure and enable it. Calling this function after it has already been initialized will return false. In order to run initialization again, reset() must be called. After initialization, the settings are committed and saved into another settings structure. This settings can be looked up and inspected by the application.   void reset()Reset the driver in order to run initialize again. This is helpful if the application needs to change the settings of a driver after it is first initialized, like baud rate for serial or pull resistor for a pin.   bool is_initialized() constDetermine if the driver has been initialized.   settings_t \u0026 settings()Get access to uncommitted driver settings.   const settings_t \u0026 initialized_settings() constGet access to the settings that were used in the latest initialization. These settings only get updated when a successful initialize() has occurred.    Protected Functions inherited from embed::driver\u003c spi_settings \u003e\n    Name     virtual bool driver_initialize() =0Implementation of driver initialize by the inherited driver.    Protected Attributes inherited from embed::driver\u003c spi_settings \u003e\n    Name     settings_t m_settings Mutable settings.   settings_t m_initialized_settings Saved version of the settings at initialization.   bool m_initialized Determines if the driver has been initialized.    Public Functions Documentation function busy virtual bool busy() =0 Determines if a transfer is currently ongoing.\nReturn:\n true transfer is currently ongoing false device is idle and available for a transaction  function transfer virtual void transfer( std::span\u003c const std::byte \u003e p_data_out, std::span\u003c std::byte \u003e p_data_in, std::byte p_write_value =std::byte{ 0xFF } ) =0 Send and receieve bytes from the spi bus.\nParameters:\n p_data_out buffer to write data to the bus. If this is set to null/empty then writing is ignored and the p_write_value will be written to the bus. If the length is less than p_data_in, then p_write_value will be written to the bus after this buffer has been sent. p_data_in buffer to read the data off of the bus. If this is null/empty, then the transfer will be write only and the incoming data will be ignored. If the length of this buffer is less than p_data_out, once this buffer has been filled, the rest of the received bytes on the bus will be dropped. p_write_value filler data to be placed on the bus when the p_data_out buffer has been exhausted.   Updated on 2021-12-10 at 15:52:40 +0000\n","description":"","tags":null,"title":"embed::spi","uri":"/libembeddedhal/api/classes/classembed_1_1spi/"},{"content":"embed::spi_settings Struct Reference\nGeneric settings for a standard SPI device.\n#include \u003cspi.hpp\u003e\nPublic Attributes     Name     uint32_t clock_rate_hz Serial clock frequency.   bool clock_idles_high The polarity of the pins when the signal is idle.   bool data_valid_on_trailing_edge The phase of the clock signal when communicating.    Public Attributes Documentation variable clock_rate_hz uint32_t clock_rate_hz = 100'000; Serial clock frequency.\nvariable clock_idles_high bool clock_idles_high = false; The polarity of the pins when the signal is idle.\nvariable data_valid_on_trailing_edge bool data_valid_on_trailing_edge = false; The phase of the clock signal when communicating.\n Updated on 2021-12-10 at 15:52:40 +0000\n","description":"","tags":null,"title":"embed::spi_settings","uri":"/libembeddedhal/api/classes/structembed_1_1spi__settings/"},{"content":"embed::static_callable Class Reference\nGeneral class which will be used to allow for signature to be used and then split by the below class. More…\nDetailed Description template \u003cclass owner_class , int reference_designator, typename signature \u003e class embed::static_callable; General class which will be used to allow for signature to be used and then split by the below class.\nTemplate Parameters:\n owner_class class that this static callable belongs to reference_designator this template argument is used to generate unique static objects for each needed callback signature function signature to be split up in the static_callable specialization   Updated on 2021-12-10 at 15:52:40 +0000\n","description":"","tags":null,"title":"embed::static_callable","uri":"/libembeddedhal/api/classes/classembed_1_1static__callable/"},{"content":"embed::static_callable\u003c owner_class, reference_designator, return_t(args_t… p_args)\u003e Class Reference\nSpecialization of static_callable with the return type and arguments split up. More…\n#include \u003cstatic_callable.hpp\u003e\nPublic Functions     Name      static_callable(std::function\u003c return_t(args_t… p_args)\u003e p_callback)Construct a new static callable object.   auto * get_handler()Get the static function’s address.    Detailed Description template \u003cclass owner_class , int reference_designator, typename return_t , typename... args_t\u003e class embed::static_callable\u003c owner_class, reference_designator, return_t(args_t... p_args)\u003e; Specialization of static_callable with the return type and arguments split up.\nTemplate Parameters:\n owner_class see static_callable reference_designator see static_callable return_t function’s return type args_t function’s set of arguments  Public Functions Documentation function static_callable inline static_callable( std::function\u003c return_t(args_t... p_args)\u003e p_callback ) Construct a new static callable object.\nParameters:\n p_callback when the static callback function is called, it will call this callback  function get_handler inline auto * get_handler() Get the static function’s address.\nReturn: auto* static function’s address\n Updated on 2021-12-10 at 15:52:40 +0000\n","description":"","tags":null,"title":"embed::static_callable\u003c owner_class, reference_designator, return_t(args_t... p_args)\u003e","uri":"/libembeddedhal/api/classes/classembed_1_1static__callable_3_01owner__class_00_01reference__designator_00_01return__t_07args__t_8_8_8_01p__args_08_4/"},{"content":"embed::static_memory_resource Class Reference\nThe static_memory_resource is the polymorphic memory resource allocator that allows libembeddedhal’s libraries to use a C++ standard container such as std::pmr::vector, std::pmr::string, std::pmr::unordered_map, and more without requiring dynamic memory allocation from the heap. It provides a simple way to create an allocator with built in storage, with its size indicated by a single template parameter. It also provides statistics regarding the amount of memory allocated such that developers can determine if they need to reduce or increase the size of the buffer. Memory statistics can also give programs the insight into how much memory space is available and make decisions based on that. In the event that the memory of the static allocator is exceeded, a std::bad_alloc excpetion is thrown. More…\n#include \u003cstatic_memory_resource.hpp\u003e\nInherits from std::pmr::memory_resource\nPublic Functions     Name      static_memory_resource()   constexpr std::size_t capacity() const   std::size_t memory_used() const   int memory_available() const    Protected Functions     Name     void * do_allocate(std::size_t p_bytes, std::size_t p_alignment) overrideImplemenation of the do_allocate() method for std::pmr::memory_resource.   void do_deallocate(void * p_address, std::size_t p_bytes, std::size_t p_alignment) overrideImplemenation of the do_deallocate() method for std::pmr::memory_resource.   bool do_is_equal(const std::pmr::memory_resource \u0026 p_other) const overrideImplemenation of the do_is_equal() method for std::pmr::memory_resource.    Detailed Description template \u003csize_t BufferSize\u003e class embed::static_memory_resource; The static_memory_resource is the polymorphic memory resource allocator that allows libembeddedhal’s libraries to use a C++ standard container such as std::pmr::vector, std::pmr::string, std::pmr::unordered_map, and more without requiring dynamic memory allocation from the heap. It provides a simple way to create an allocator with built in storage, with its size indicated by a single template parameter. It also provides statistics regarding the amount of memory allocated such that developers can determine if they need to reduce or increase the size of the buffer. Memory statistics can also give programs the insight into how much memory space is available and make decisions based on that. In the event that the memory of the static allocator is exceeded, a std::bad_alloc excpetion is thrown.\nTemplate Parameters:\n BufferSize number of bytes to statically allocate for the memory resource.  USAGE:\n// Make a memory resource with 1kB buffer static_memory_resource\u003c1024\u003e memory_resource; std::pmr::unordered_map\u003cint, const char*\u003e id_name_map(\u0026memory_resource);\nPublic Functions Documentation function static_memory_resource inline static_memory_resource() function capacity inline constexpr std::size_t capacity() const Return: constexpr std::size_t - the total number of bytes that this allocator can allocate before throwing a std::bad_alloc exception.\nfunction memory_used inline std::size_t memory_used() const Return: std::size_t number of bytes that have already been allocated.\nfunction memory_available inline int memory_available() const Return: int Bytes that have yet to be allocated from this allocator.\nProtected Functions Documentation function do_allocate inline void * do_allocate( std::size_t p_bytes, std::size_t p_alignment ) override Implemenation of the do_allocate() method for std::pmr::memory_resource.\nParameters:\n p_bytes number of bytes to allocate p_alignment alignment limit for the allocation  Return: void* address of the newly allocated buffer\nfunction do_deallocate inline void do_deallocate( void * p_address, std::size_t p_bytes, std::size_t p_alignment ) override Implemenation of the do_deallocate() method for std::pmr::memory_resource.\nParameters:\n p_address address of space to be deallocated p_bytes number of bytes to allocate p_alignment alignment limit for the allocation  function do_is_equal inline bool do_is_equal( const std::pmr::memory_resource \u0026 p_other ) const override Implemenation of the do_is_equal() method for std::pmr::memory_resource.\nParameters:\n p_other another memory resource to  Return:\n true are equal false are not equal   Updated on 2021-12-10 at 15:52:40 +0000\n","description":"","tags":null,"title":"embed::static_memory_resource","uri":"/libembeddedhal/api/classes/classembed_1_1static__memory__resource/"},{"content":"embed::this_thread Namespace Reference\nClasses     Name     struct embed::this_thread::global_clocks structure containing internal clock variables and functions    Types     Name     using std::chrono::nanoseconds time_increment smallest increment of time for clocks   using std::function\u003c void(time_increment p_sleep_time)\u003e sleep_function definition of a sleep function   using std::function\u003c time_increment(void)\u003e uptime_function definition of an uptime function    Functions     Name     auto sleep_for(time_increment p_delay)Delay execution of the program by a predefined time.   auto uptime()Get the current system uptime.   void set_global_sleep(sleep_function p_sleep_function)Set the global sleep object.   void set_global_uptime(uptime_function p_uptime_function)Set the global uptime object.    Types Documentation using time_increment using embed::this_thread::time_increment = typedef std::chrono::nanoseconds; smallest increment of time for clocks\nusing sleep_function using embed::this_thread::sleep_function = typedef std::function\u003cvoid(time_increment p_sleep_time)\u003e; definition of a sleep function\nusing uptime_function using embed::this_thread::uptime_function = typedef std::function\u003ctime_increment(void)\u003e; definition of an uptime function\nFunctions Documentation function sleep_for static auto sleep_for( time_increment p_delay ) Delay execution of the program by a predefined time.\nParameters:\n p_delay the amount of time to delay execution by  function uptime static auto uptime() Get the current system uptime.\nReturn: auto the global uptime\nfunction set_global_sleep static void set_global_sleep( sleep_function p_sleep_function ) Set the global sleep object.\nParameters:\n p_sleep_function the function to handle sleeping  function set_global_uptime static void set_global_uptime( uptime_function p_uptime_function ) Set the global uptime object.\nParameters:\n p_uptime_function the function to return the current system uptime   Updated on 2021-12-10 at 15:52:40 +0000\n","description":"","tags":null,"title":"embed::this_thread","uri":"/libembeddedhal/api/namespaces/namespaceembed_1_1this__thread/"},{"content":"embed::this_thread::global_clocks Struct Reference\nstructure containing internal clock variables and functions\n#include \u003ctime.hpp\u003e\nPublic Functions     Name     time_increment incremental_uptime()Default uptime timer that simply counts each time it is called. This should almost never be used.   void loop_sleep(time_increment p_loop_count)Default sleep function that simply counts until it reaches a designated number.    Public Attributes     Name     sleep_function m_global_sleep Store the global sleep function.   uptime_function m_global_uptime Store the global uptime function.    Public Functions Documentation function incremental_uptime static inline time_increment incremental_uptime() Default uptime timer that simply counts each time it is called. This should almost never be used.\nReturn: time_increment fake uptime\nfunction loop_sleep static inline void loop_sleep( time_increment p_loop_count ) Default sleep function that simply counts until it reaches a designated number.\nParameters:\n p_loop_count number of iterations to loop for to mimick sleeping  Public Attributes Documentation variable m_global_sleep static sleep_function m_global_sleep = loop_sleep; Store the global sleep function.\nvariable m_global_uptime static uptime_function m_global_uptime = incremental_uptime; Store the global uptime function.\n Updated on 2021-12-10 at 15:52:40 +0000\n","description":"","tags":null,"title":"embed::this_thread::global_clocks","uri":"/libembeddedhal/api/classes/structembed_1_1this__thread_1_1global__clocks/"},{"content":"embed::timer Class Reference\nTimer hardware abstraction interface. More…\n#include \u003ctimer.hpp\u003e\nInherits from embed::driver\u003c\u003e\nPublic Types     Name     enum class controls { start, stop, reset}Set of controls for a timer.   enum class type { oneshot, continuous}Type of timer.    Public Functions     Name     virtual bool is_running() =0Determine if the timer is currently running.   virtual void control(controls p_control) =0Control the state of the timer.   virtual bool attach_interrupt(std::function\u003c void(void)\u003e p_callback, std::chrono::nanoseconds p_interval, type p_type =type::continuous) =0Setup the timer and attach an interrupt to it.    Additional inherited members Public Functions inherited from embed::driver\u003c\u003e\n    Name     bool initialize()Initialize the driver, apply the setting as defined in the settings_t structure and enable it. Calling this function after it has already been initialized will return false. In order to run initialization again, reset() must be called. After initialization, the settings are committed and saved into another settings structure. This settings can be looked up and inspected by the application.   void reset()Reset the driver in order to run initialize again. This is helpful if the application needs to change the settings of a driver after it is first initialized, like baud rate for serial or pull resistor for a pin.   bool is_initialized() constDetermine if the driver has been initialized.   settings_t \u0026 settings()Get access to uncommitted driver settings.   const settings_t \u0026 initialized_settings() constGet access to the settings that were used in the latest initialization. These settings only get updated when a successful initialize() has occurred.    Protected Functions inherited from embed::driver\u003c\u003e\n    Name     virtual bool driver_initialize() =0Implementation of driver initialize by the inherited driver.    Protected Attributes inherited from embed::driver\u003c\u003e\n    Name     settings_t m_settings Mutable settings.   settings_t m_initialized_settings Saved version of the settings at initialization.   bool m_initialized Determines if the driver has been initialized.    Detailed Description class embed::timer; Timer hardware abstraction interface.\nUse this interface for devices and peripherals that have timer like capabilities, such that, when a timer’s time has expired, an event/interrupt/signal is generated.\nPublic Types Documentation enum controls    Enumerator Value Description     start  Control value to start the timer.   stop  Control value to stop a timer.   reset  Control value to reset a timer. The timer shall remain in a running or stopped state after this call. So an ongoing timer will continue to count but will have its counter reset to zero if this control is used. If a timer is stopped, then it shall be reset to zero, and stay stopped.    Set of controls for a timer.\nenum type    Enumerator Value Description     oneshot  Once the timer’s time has been reached an interrupt will fire and the timer will be stopped.   continuous  Once the timer’s time has been reached an interrupt will fire and the timer will be reset and will begin counting again.    Type of timer.\nPublic Functions Documentation function is_running virtual bool is_running() =0 Determine if the timer is currently running.\nReturn:\n true timer is currently running false timer is currently stopped  function control virtual void control( controls p_control ) =0 Control the state of the timer.\nParameters:\n p_control new state for the timer  function attach_interrupt virtual bool attach_interrupt( std::function\u003c void(void)\u003e p_callback, std::chrono::nanoseconds p_interval, type p_type =type::continuous ) =0 Setup the timer and attach an interrupt to it.\nParameters:\n p_callback callback function to be called when the timer expires p_interval the amount of time before the timer expires p_type the type of timer this is  Return:\n true successfully set all parameters false not all parameters could be met such as an interval smaller than is capable by hardware or an unsupported timer type.  When called this will, stop and reset the timer. To start the timer, control(controls::start) must be called.\n Updated on 2021-12-10 at 15:52:40 +0000\n","description":"","tags":null,"title":"embed::timer","uri":"/libembeddedhal/api/classes/classembed_1_1timer/"},{"content":" Updated on 2021-12-10 at 15:52:40 +0000\n","description":"","tags":null,"title":"Modules","uri":"/libembeddedhal/api/modules/"},{"content":" namespace embed  namespace this_thread     Updated on 2021-12-10 at 15:52:40 +0000\n","description":"","tags":null,"title":"Namespaces","uri":"/libembeddedhal/api/namespaces/"},{"content":" Updated on 2021-12-10 at 15:52:40 +0000\n","description":"","tags":null,"title":"Pages","uri":"/libembeddedhal/api/pages/"},{"content":"","description":"","tags":null,"title":"Tags","uri":"/libembeddedhal/tags/"},{"content":"Welcome! TBD\n","description":"","tags":null,"title":"Welcome","uri":"/libembeddedhal/"}]