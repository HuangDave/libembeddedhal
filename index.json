[{"content":"Quick Start Prerequisites Lorem Ipsum.\n","description":"","tags":null,"title":"Basics","uri":"/libembeddedhal/basics/"},{"content":"Welcome to libembeddedhal! TBD\n","description":"","tags":null,"title":"Welcome","uri":"/libembeddedhal/"},{"content":"Testing this out Some content for you!\n","description":"","tags":null,"title":"First Content","uri":"/libembeddedhal/basics/first-content/"},{"content":"","description":"","tags":null,"title":"Apis","uri":"/libembeddedhal/api/"},{"content":"","description":"","tags":null,"title":"Categories","uri":"/libembeddedhal/categories/"},{"content":" namespace embed  class adc Analog to Digital Converter (ADC) hardware abstraction interface. Use this interface for devices and peripherals that can convert analog voltage signals into a digital number. struct bit_depth class bit_limits class can  struct message_t   class can_network can_network is a canbus message receiver handler and  class node_t   struct can_settings class counter Counter hardware abstraction interface. Use this interface for devices and peripherals that have counting capabilities. Such devices can count up or down. Useful for keeping time. Expect counters to overflow when they reach the end of counting register’s limits. class dac Digital to Analog Converter (DAC) hardware abstraction interface. Use this interface for devices and peripherals that can create arbitrary analog voltages between a defined LOW and HIGH voltage. class driver The basis class for all peripheral, device and system drivers in libembeddedhal. class full_scale class i2c Inter-integrated Circuit (I2C) or Two Wire Interface (TWI) communication protocol hardware abstract interface. struct i2c_settings Generic settings for a standard I2C device. class input_pin Digital input pin hardware abstraction. Use this to read a pin and determine if the voltage on it is HIGH or LOW. struct input_pin_settings Generic settings for input pins. class interrupt_pin Digital interrupt pin hardware abstraction. Use this to trigger an interrupt service routine (ISR) when a pin detects a falling edge (when the pin’s voltage transitions from HIGH to LOW), a rising edge (when the pin’s voltage transitions from LOW to HIGH), or any transition of state on the pin. struct interrupt_pin_settings Generic settings for interrupt pins. struct invalid_option_t Used for defining static_asserts that should always fail, but only if the static_assert line is hit via if constexpr control block. Prefer to NOT use this directly but to use invalid_option instead. struct no_settings An empty settings structure used to indicate that a driver or interface does not have generic settings. class output_pin Digital output pin hardware abstraction. Use this to drive a pin HIGH or LOW in order to send a control signal or turn off or on an LED. struct output_pin_settings Generic settings for output pins. class pwm Pulse Width Modulation (PWM) channel hardware abstraction. class serial Serial communication protocol hardware abstract interface. Use this interface for hardware that implements a serial protocol like UART, USART, RS232, RS485 and many others that use a similar communication protocol but may use different voltage schemes. struct serial_settings Generic settings for a standard serial device. class spi Serial peripheral interface (SPI) communication protocol hardware abstract interface. struct spi_settings Generic settings for a standard SPI device. class static_callable General class which will be used to allow for signature to be used and then split by the below class. class static_callable\u003c owner_class, reference_designator, return_t(args_t…)\u003e Specialization of static_callable with the return type and arguments split up. class static_memory_resource The static_memory_resource is the polymorphic memory resource allocator that allows libembeddedhal’s libraries to use a C++ standard container such as std::pmr::vector, std::pmr::string, std::pmr::unordered_map, and more without requiring dynamic memory allocation from the heap. It provides a simple way to create an allocator with built in storage, with its size indicated by a single template parameter. It also provides statistics regarding the amount of memory allocated such that developers can determine if they need to reduce or increase the size of the buffer. Memory statistics can also give programs the insight into how much memory space is available and make decisions based on that. In the event that the memory of the static allocator is exceeded, a std::bad_alloc excpetion is thrown. namespace this_thread  struct global_clocks internal clock   class timer Timer hardware abstraction interface. Use this interface for devices and peripherals that have timer like capabilities, such that, when a timer’s time has expired, an event/interrupt/signal is generated.     Updated on 2021-12-04 at 16:50:11 +0000\n","description":"","tags":null,"title":"Classes","uri":"/libembeddedhal/api/classes/"},{"content":"embed Namespace Reference\nNamespaces    Name     embed::this_thread    Classes     Name     class embed::adc Analog to Digital Converter (ADC) hardware abstraction interface. Use this interface for devices and peripherals that can convert analog voltage signals into a digital number.   struct embed::can_settings   class embed::can   class embed::can_network can_network is a canbus message receiver handler and   class embed::counter Counter hardware abstraction interface. Use this interface for devices and peripherals that have counting capabilities. Such devices can count up or down. Useful for keeping time. Expect counters to overflow when they reach the end of counting register’s limits.   class embed::dac Digital to Analog Converter (DAC) hardware abstraction interface. Use this interface for devices and peripherals that can create arbitrary analog voltages between a defined LOW and HIGH voltage.   struct embed::invalid_option_t Used for defining static_asserts that should always fail, but only if the static_assert line is hit via if constexpr control block. Prefer to NOT use this directly but to use invalid_option instead.   struct embed::no_settings An empty settings structure used to indicate that a driver or interface does not have generic settings.   class embed::driver The basis class for all peripheral, device and system drivers in libembeddedhal.   class embed::bit_limits   struct embed::bit_depth   class embed::full_scale   struct embed::input_pin_settings Generic settings for input pins.   struct embed::output_pin_settings Generic settings for output pins.   struct embed::interrupt_pin_settings Generic settings for interrupt pins.   class embed::input_pin Digital input pin hardware abstraction. Use this to read a pin and determine if the voltage on it is HIGH or LOW.   class embed::output_pin Digital output pin hardware abstraction. Use this to drive a pin HIGH or LOW in order to send a control signal or turn off or on an LED.   class embed::interrupt_pin Digital interrupt pin hardware abstraction. Use this to trigger an interrupt service routine (ISR) when a pin detects a falling edge (when the pin’s voltage transitions from HIGH to LOW), a rising edge (when the pin’s voltage transitions from LOW to HIGH), or any transition of state on the pin.   struct embed::i2c_settings Generic settings for a standard I2C device.   class embed::i2c Inter-integrated Circuit (I2C) or Two Wire Interface (TWI) communication protocol hardware abstract interface.   class embed::pwm Pulse Width Modulation (PWM) channel hardware abstraction.   struct embed::serial_settings Generic settings for a standard serial device.   class embed::serial Serial communication protocol hardware abstract interface. Use this interface for hardware that implements a serial protocol like UART, USART, RS232, RS485 and many others that use a similar communication protocol but may use different voltage schemes.   struct embed::spi_settings Generic settings for a standard SPI device.   class embed::spi Serial peripheral interface (SPI) communication protocol hardware abstract interface.   class embed::static_callable General class which will be used to allow for signature to be used and then split by the below class.   class embed::static_callable\u003c owner_class, reference_designator, return_t(args_t…)\u003e Specialization of static_callable with the return type and arguments split up.   class embed::static_memory_resource The static_memory_resource is the polymorphic memory resource allocator that allows libembeddedhal’s libraries to use a C++ standard container such as std::pmr::vector, std::pmr::string, std::pmr::unordered_map, and more without requiring dynamic memory allocation from the heap. It provides a simple way to create an allocator with built in storage, with its size indicated by a single template parameter. It also provides statistics regarding the amount of memory allocated such that developers can determine if they need to reduce or increase the size of the buffer. Memory statistics can also give programs the insight into how much memory space is available and make decisions based on that. In the event that the memory of the static allocator is exceeded, a std::bad_alloc excpetion is thrown.   class embed::timer Timer hardware abstraction interface. Use this interface for devices and peripherals that have timer like capabilities, such that, when a timer’s time has expired, an event/interrupt/signal is generated.    Types     Name     enum class pin_resistor { none = 0, pull_down, pull_up}Set of possible pin mode resistor settings. See each enumeration to get more details about when and how these should be used.    Functions     Name     constexpr bool is_platform(std::string_view p_platform)Determines if the current application was built for a specific platform. For example:   constexpr bool is_a_test()Determines if the application is a test.   template \u003ctypename enum_type \u003e constexpr auto value(enum_type enum_value)Helper function to convert an enum to its integral value.   template \u003csize_t bit_field_width\u003e consteval uint32_t generate_field_of_ones()Generate a mask of 1s at compiletime.   template \u003ctypename T ,size_t source_width,typename U \u003e constexpr static T increase_bit_depth(U p_value)   template \u003cstd::unsigned_integral T,std::unsigned_integral U\u003e auto operator*(U value, full_scale\u003c T \u003e scale)    Attributes     Name     constexpr const std::string_view platform_string The platform string determines which platform this application was built for. Use this to determine at compile or runtime if the running application is a “test”, an “lpc40” series mcu, and “stm” series mcu or a raspberry pi (“rpi”).   constexpr bool invalid_option Helper definition to simplify the usage of invalid_option_t.    Types Documentation enum pin_resistor    Enumerator Value Description     none 0 No pull up. This will cause the pin to float. This may be desirable if the pin has an external resistor attached or if the signal is sensitive to external devices like resistors.   pull_down  Pull the pin down to devices GND. This will ensure that the voltage read by the pin when there is no signal on the pin is LOW (or false).   pull_up  See pull down explanation, but in this case the pin is pulled up to VCC, also called VDD on some systems.    Set of possible pin mode resistor settings. See each enumeration to get more details about when and how these should be used.\nFunctions Documentation function is_platform constexpr bool is_platform( std::string_view p_platform ) Determines if the current application was built for a specific platform. For example:\nParameters:\n p_platform platform string pattern to check against  Return:\n true matches the platform string false does not matches the platform string  embed::is_platform(“lpc4078”);\nWill return true if the PLATFORM macro defined at compile time was equal to lpc4078. If the developer wants to be less specific, let say, to just determine if the platform is in the lpc40xx family then the following example will work.\nembed::is_platform(“lpc40”);\nfunction is_a_test constexpr bool is_a_test() Determines if the application is a test.\nReturn:\n true this application is a test false this application is not a test  function value template \u003ctypename enum_type \u003e constexpr auto value( enum_type enum_value ) Helper function to convert an enum to its integral value.\nParameters:\n enum_value the enumeration you want to convert into an integral value  Template Parameters:\n enum_type the underlying type of the enumeration. Do not supply this value, it is inferred by the enum_value passed to the function.  Return: constexpr auto return the integral value of the enum.\nfunction generate_field_of_ones template \u003csize_t bit_field_width\u003e static consteval uint32_t generate_field_of_ones() Generate a mask of 1s at compiletime.\nTemplate Parameters:\n bit_field_width number of 1s in the mask  Return: consteval uint32_t mask with 1s at the LSB\nfunction increase_bit_depth template \u003ctypename T , size_t source_width, typename U \u003e static constexpr static T increase_bit_depth( U p_value ) Parameters:\n p_value  Template Parameters:\n T source_width U  Return: constexpr T\nfunction operator* template \u003cstd::unsigned_integral T, std::unsigned_integral U\u003e auto operator*( U value, full_scale\u003c T \u003e scale ) Parameters:\n value scale  Template Parameters:\n T U  Return: auto\nAttributes Documentation variable platform_string constexpr const std::string_view platform_string = PLATFORM_STRING; The platform string determines which platform this application was built for. Use this to determine at compile or runtime if the running application is a “test”, an “lpc40” series mcu, and “stm” series mcu or a raspberry pi (“rpi”).\nvariable invalid_option constexpr bool invalid_option = invalid_option_t\u003coptions...\u003e::value; Helper definition to simplify the usage of invalid_option_t.\nTemplate Parameters:\n options ignored by the application but needed to create a non-trivial specialization of this class which allows its usage in static_assert.   Updated on 2021-12-04 at 16:50:11 +0000\n","description":"","tags":null,"title":"embed","uri":"/libembeddedhal/api/namespaces/namespaceembed/"},{"content":"embed::adc Class Reference\nAnalog to Digital Converter (ADC) hardware abstraction interface. Use this interface for devices and peripherals that can convert analog voltage signals into a digital number.\n#include \u003cadc.hpp\u003e\nInherits from embed::driver\u003c\u003e\nAdditional inherited members Public Functions inherited from embed::driver\u003c\u003e\n    Name     bool initialize()Initialize the driver, apply the setting as defined in the settings_t structure and enable it. Calling this function after it has already been initialized will return false. In order to run initialization again, reset() must be called. After initialization, the settings are committed and saved into another settings structure. This settings can be looked up and inspected by the application.   void reset()Reset the driver in order to run initialize again. This is helpful if the application needs to change the settings of a driver after it is first initialized, like baud rate for serial or pull resistor for a pin.   bool is_initialized() constDetermine if the driver has been initialized.   settings_t \u0026 settings()Get access to uncommitted driver settings.   const settings_t \u0026 initialized_settings() constGet access to the settings that were used in the latest initialization. These settings only get updated when a successful initialize() has occurred.    Protected Functions inherited from embed::driver\u003c\u003e\n    Name     virtual bool driver_initialize() =0    Protected Attributes inherited from embed::driver\u003c\u003e\n    Name     settings_t m_settings   settings_t m_initialized_settings   bool m_initialized     Updated on 2021-12-04 at 16:50:11 +0000\n","description":"","tags":null,"title":"embed::adc","uri":"/libembeddedhal/api/classes/classembed_1_1adc/"},{"content":"embed::bit_depth Struct Reference\nMore…\n#include \u003cfull_scale.hpp\u003e\nPublic Functions     Name     constexpr bit_depth(T p_value)    Public Attributes     Name     T value    Detailed Description template \u003ctypename T , size_t bit_width\u003e struct embed::bit_depth; Template Parameters:\n T bit_width  Public Functions Documentation function bit_depth inline constexpr bit_depth( T p_value ) Public Attributes Documentation variable value T value = 0;  Updated on 2021-12-04 at 16:50:11 +0000\n","description":"","tags":null,"title":"embed::bit_depth","uri":"/libembeddedhal/api/classes/structembed_1_1bit__depth/"},{"content":"embed::bit_limits Class Reference\nMore…\n#include \u003cfull_scale.hpp\u003e\nPublic Functions     Name     constexpr int_t max()Get the maximum value available for an integer of bit_width size and that can be stored within int_t. The final value of the function depends also on the sign of the int type.   constexpr int_t min()Get the minimum value available for an integer of bit_width size and that can be stored within int_t. The final value of the function depends also on the sign of the int type. Unsigned ints simply return zero.    Detailed Description template \u003cuint8_t bit_width, typename int_t \u003e class embed::bit_limits; Template Parameters:\n bit_width int_t  Public Functions Documentation function max static inline constexpr int_t max() Get the maximum value available for an integer of bit_width size and that can be stored within int_t. The final value of the function depends also on the sign of the int type.\nReturn:\n constexpr int_t - returns the maximum value available for an integer of bit_width size and that can be stored within int_t. The final value of the function depends also on the sign of the int type. constexpr int_t maximum value  function min static inline constexpr int_t min() Get the minimum value available for an integer of bit_width size and that can be stored within int_t. The final value of the function depends also on the sign of the int type. Unsigned ints simply return zero.\nReturn: constexpr int_t minimum value\n Updated on 2021-12-04 at 16:50:11 +0000\n","description":"","tags":null,"title":"embed::bit_limits","uri":"/libembeddedhal/api/classes/classembed_1_1bit__limits/"},{"content":"embed::can Class Reference\n#include \u003ccan.hpp\u003e\nInherits from embed::driver\u003c can_settings \u003e\nPublic Classes     Name     struct message_t    Public Types     Name     using uint32_t id_t    Public Functions     Name     virtual void send(const message_t \u0026 p_message) =0   virtual message_t receive() =0   virtual bool has_data() =0   virtual void attach_interrupt(std::function\u003c void(can \u0026)\u003e p_receive_handler) =0Will attach an interrupt to this can driver such that, when a message is received, it will call the handler supplied.    Additional inherited members Public Functions inherited from embed::driver\u003c can_settings \u003e\n    Name     bool initialize()Initialize the driver, apply the setting as defined in the settings_t structure and enable it. Calling this function after it has already been initialized will return false. In order to run initialization again, reset() must be called. After initialization, the settings are committed and saved into another settings structure. This settings can be looked up and inspected by the application.   void reset()Reset the driver in order to run initialize again. This is helpful if the application needs to change the settings of a driver after it is first initialized, like baud rate for serial or pull resistor for a pin.   bool is_initialized() constDetermine if the driver has been initialized.   settings_t \u0026 settings()Get access to uncommitted driver settings.   const settings_t \u0026 initialized_settings() constGet access to the settings that were used in the latest initialization. These settings only get updated when a successful initialize() has occurred.    Protected Functions inherited from embed::driver\u003c can_settings \u003e\n    Name     virtual bool driver_initialize() =0    Protected Attributes inherited from embed::driver\u003c can_settings \u003e\n    Name     settings_t m_settings   settings_t m_initialized_settings   bool m_initialized    Public Types Documentation using id_t using embed::can::id_t = uint32_t; Public Functions Documentation function send virtual void send( const message_t \u0026 p_message ) =0 function receive virtual message_t receive() =0 function has_data virtual bool has_data() =0 function attach_interrupt virtual void attach_interrupt( std::function\u003c void(can \u0026)\u003e p_receive_handler ) =0 Will attach an interrupt to this can driver such that, when a message is received, it will call the handler supplied.\nParameters:\n p_receive_handler - Handler to be called when a message is received. If this is set to nullptr, then this function shall disable the can interrupt or replace the interrupt with a function that does nothing, but still clears the interrupt service routine.   Updated on 2021-12-04 at 16:50:11 +0000\n","description":"","tags":null,"title":"embed::can","uri":"/libembeddedhal/api/classes/classembed_1_1can/"},{"content":"embed::can::message_t Struct Reference\n#include \u003ccan.hpp\u003e\nPublic Attributes     Name     id_t id   uint8_t length   std::array\u003c uint8_t, 8 \u003e payload   bool is_remote_request    Public Attributes Documentation variable id id_t id; variable length uint8_t length = 0; variable payload std::array\u003c uint8_t, 8 \u003e payload {0}; variable is_remote_request bool is_remote_request = false;  Updated on 2021-12-04 at 16:50:11 +0000\n","description":"","tags":null,"title":"embed::can::message_t","uri":"/libembeddedhal/api/classes/structembed_1_1can_1_1message__t/"},{"content":"embed::can_network Class Reference\ncan_network is a canbus message receiver handler and\n#include \u003ccan_network.hpp\u003e\nInherits from embed::driver\u003c\u003e\nPublic Classes     Name     class node_t    Public Functions     Name      can_network(can \u0026 p_can, std::pmr::memory_resource \u0026 p_memory_resource)   virtual bool driver_initialize() override   node_t * register_message_id(can::id_t id)   void manually_call_receive_handler()   can \u0026 bus()   const auto \u0026 GetInternalMap()    Additional inherited members Public Functions inherited from embed::driver\u003c\u003e\n    Name     bool initialize()Initialize the driver, apply the setting as defined in the settings_t structure and enable it. Calling this function after it has already been initialized will return false. In order to run initialization again, reset() must be called. After initialization, the settings are committed and saved into another settings structure. This settings can be looked up and inspected by the application.   void reset()Reset the driver in order to run initialize again. This is helpful if the application needs to change the settings of a driver after it is first initialized, like baud rate for serial or pull resistor for a pin.   bool is_initialized() constDetermine if the driver has been initialized.   settings_t \u0026 settings()Get access to uncommitted driver settings.   const settings_t \u0026 initialized_settings() constGet access to the settings that were used in the latest initialization. These settings only get updated when a successful initialize() has occurred.    Protected Attributes inherited from embed::driver\u003c\u003e\n    Name     settings_t m_settings   settings_t m_initialized_settings   bool m_initialized    Public Functions Documentation function can_network inline can_network( can \u0026 p_can, std::pmr::memory_resource \u0026 p_memory_resource ) Parameters:\n can - CAN peripheral to manage the network of. memory_resource - pointer to a memory resource.  function driver_initialize inline virtual bool driver_initialize() override Reimplements: embed::driver::driver_initialize\nfunction register_message_id inline node_t * register_message_id( can::id_t id ) Parameters:\n id - Associated ID of messages to be stored.  Exceptions:\n std::bad_alloc if this static storage allocated for this object is not enough to hold  Return: node_t* - reference to the CANBUS network node_t which can be used at anytime to retreive the latest received message from the CANBUS that is associated with the set ID.\nIn order for a CAN message with an associated ID to be stored in the can_network, it must be declared using this method. For example if you expect to get the following IDs 0x140, 0x7AA, and 0x561 from the CAN bus, then this method must be called as such:\nnode_t * motor_node = can_network.register_message_id(0x140); node_t * encoder_node = can_network.register_message_id(0x561); node_t * temperature_node = can_network.register_message_id(0x7AA); function manually_call_receive_handler inline void manually_call_receive_handler() Manually call the receive handler. This is useful for unit testing and for CANBUS peripherals that do NOT have a receive message interrupt routine. In the later case, a software (potentially a thread) can perform the receive call manually to extract messages from the CAN peripheral FIFO. This method cannot guarantee that data is not lost if the FIFO fills up.\nfunction bus inline can \u0026 bus() Return the CAN peripheral object which can be used to initialize, configure, and enable the peripheral as well as transmit messages. Access to this object, if a can_network\nfunction GetInternalMap inline const auto \u0026 GetInternalMap() Meant for testing purposes or when direct inspection of the map is useful in userspace. Should not be used in by libraries.\n Updated on 2021-12-04 at 16:50:11 +0000\n","description":"","tags":null,"title":"embed::can_network","uri":"/libembeddedhal/api/classes/classembed_1_1can__network/"},{"content":"embed::can_network::node_t Class Reference\nMore…\n#include \u003ccan_network.hpp\u003e\nPublic Functions     Name      node_t()Default constructor.   node_t \u0026 operator=(const node_t \u0026 node)Node assignment operator.    node_t(const node_t \u0026 node)Copy constructor.   can::message_t secure_get()    Detailed Description class embed::can_network::node_t; The node stored in the can_network map. Holds the latest CAN message and contains methods for updating and retreiving can messages in a thread-safe manner that does not invoke OS locks.\nUpdating the CAN message data is completely lock free. Retrieving data is NOT lock free, but instead uses atomics to poll for when the update() function has completed in some other thread. This asymmetry in locking is to reduce latency for write case rather than than read case. Storing a CAN message is typically done via an interrupt service routine or a thread that MUST NOT block in anyway or the system can lock up. Where as reading data typically is done by a userspace thread which can typically wait a few cycles to get its data.\nPublic Functions Documentation function node_t inline node_t() Default constructor.\nfunction operator= inline node_t \u0026 operator=( const node_t \u0026 node ) Node assignment operator.\nfunction node_t inline node_t( const node_t \u0026 node ) Copy constructor.\nfunction secure_get inline can::message_t secure_get() Return a CAN message, but only do so if the CAN message of this node is not currently be modified by another thread that is using the update() method.\n Updated on 2021-12-04 at 16:50:11 +0000\n","description":"","tags":null,"title":"embed::can_network::node_t","uri":"/libembeddedhal/api/classes/classembed_1_1can__network_1_1node__t/"},{"content":"embed::can_settings Struct Reference\n#include \u003ccan.hpp\u003e\nPublic Attributes     Name     uint32_t clock_rate_hz    Public Attributes Documentation variable clock_rate_hz uint32_t clock_rate_hz = 100'000;  Updated on 2021-12-04 at 16:50:11 +0000\n","description":"","tags":null,"title":"embed::can_settings","uri":"/libembeddedhal/api/classes/structembed_1_1can__settings/"},{"content":"embed::counter Class Reference\nCounter hardware abstraction interface. Use this interface for devices and peripherals that have counting capabilities. Such devices can count up or down. Useful for keeping time. Expect counters to overflow when they reach the end of counting register’s limits.\n#include \u003ccounter.hpp\u003e\nInherits from embed::driver\u003c\u003e\nPublic Types     Name     enum class controls { start, stop, reset}Set of controls for a counter.    Public Functions     Name     virtual bool is_running() =0Determine if the counter is currently running.   virtual void control(controls p_control) =0Control the state of the counter.   virtual void period(std::chrono::nanoseconds p_period) =0Period for each count of the timer. For example a period of 1ms and a count of 500 would mean that 500ms has elapse since the counter has been started.   virtual std::chrono::nanoseconds period() =0Get the current period for the counter.   virtual uint64_t count() =0Get the count of the counter.    Additional inherited members Public Functions inherited from embed::driver\u003c\u003e\n    Name     bool initialize()Initialize the driver, apply the setting as defined in the settings_t structure and enable it. Calling this function after it has already been initialized will return false. In order to run initialization again, reset() must be called. After initialization, the settings are committed and saved into another settings structure. This settings can be looked up and inspected by the application.   void reset()Reset the driver in order to run initialize again. This is helpful if the application needs to change the settings of a driver after it is first initialized, like baud rate for serial or pull resistor for a pin.   bool is_initialized() constDetermine if the driver has been initialized.   settings_t \u0026 settings()Get access to uncommitted driver settings.   const settings_t \u0026 initialized_settings() constGet access to the settings that were used in the latest initialization. These settings only get updated when a successful initialize() has occurred.    Protected Functions inherited from embed::driver\u003c\u003e\n    Name     virtual bool driver_initialize() =0    Protected Attributes inherited from embed::driver\u003c\u003e\n    Name     settings_t m_settings   settings_t m_initialized_settings   bool m_initialized    Public Types Documentation enum controls    Enumerator Value Description     start  Control value to start the counter.   stop  Control value to stop a counter.   reset  Control value to reset a counter. The counter shall remain in a running or stopped state after this call. So an ongoing counter will continue to count but will have its counter reset to zero if this control is used. If a counter is stopped, then it shall be reset to zero, and stay stopped.    Set of controls for a counter.\nPublic Functions Documentation function is_running virtual bool is_running() =0 Determine if the counter is currently running.\nReturn:\n true counter is currently running false counter is currently stopped  function control virtual void control( controls p_control ) =0 Control the state of the counter.\nParameters:\n p_control new state for the counter  function period virtual void period( std::chrono::nanoseconds p_period ) =0 Period for each count of the timer. For example a period of 1ms and a count of 500 would mean that 500ms has elapse since the counter has been started.\nParameters:\n p_period the amount of time each count should be.  function period virtual std::chrono::nanoseconds period() =0 Get the current period for the counter.\nReturn: std::chrono::nanoseconds\nfunction count virtual uint64_t count() =0 Get the count of the counter.\nReturn: uint64_t current count\n Updated on 2021-12-04 at 16:50:11 +0000\n","description":"","tags":null,"title":"embed::counter","uri":"/libembeddedhal/api/classes/classembed_1_1counter/"},{"content":"embed::dac Class Reference\nDigital to Analog Converter (DAC) hardware abstraction interface. Use this interface for devices and peripherals that can create arbitrary analog voltages between a defined LOW and HIGH voltage.\n#include \u003cdac.hpp\u003e\nInherits from embed::driver\u003c\u003e\nPublic Functions     Name     virtual void write(full_scale\u003c uint32_t \u003e value) =0Generate a voltage between a defined LOW and HIGH voltage. The LOW and HIGH voltage are generally configured by a reference voltage (usually denoted Vref) connected to the device. Generally though, the low voltage is 0V and the high voltage reference is VCC.    Additional inherited members Public Functions inherited from embed::driver\u003c\u003e\n    Name     bool initialize()Initialize the driver, apply the setting as defined in the settings_t structure and enable it. Calling this function after it has already been initialized will return false. In order to run initialization again, reset() must be called. After initialization, the settings are committed and saved into another settings structure. This settings can be looked up and inspected by the application.   void reset()Reset the driver in order to run initialize again. This is helpful if the application needs to change the settings of a driver after it is first initialized, like baud rate for serial or pull resistor for a pin.   bool is_initialized() constDetermine if the driver has been initialized.   settings_t \u0026 settings()Get access to uncommitted driver settings.   const settings_t \u0026 initialized_settings() constGet access to the settings that were used in the latest initialization. These settings only get updated when a successful initialize() has occurred.    Protected Functions inherited from embed::driver\u003c\u003e\n    Name     virtual bool driver_initialize() =0    Protected Attributes inherited from embed::driver\u003c\u003e\n    Name     settings_t m_settings   settings_t m_initialized_settings   bool m_initialized    Public Functions Documentation function write virtual void write( full_scale\u003c uint32_t \u003e value ) =0 Generate a voltage between a defined LOW and HIGH voltage. The LOW and HIGH voltage are generally configured by a reference voltage (usually denoted Vref) connected to the device. Generally though, the low voltage is 0V and the high voltage reference is VCC.\nParameters:\n value precentage scale from LOW to HIGH   Updated on 2021-12-04 at 16:50:11 +0000\n","description":"","tags":null,"title":"embed::dac","uri":"/libembeddedhal/api/classes/classembed_1_1dac/"},{"content":"embed::driver Class Reference\nThe basis class for all peripheral, device and system drivers in libembeddedhal. More…\n#include \u003cdriver.hpp\u003e\nInherited by embed::adc, embed::can_network, embed::counter, embed::dac, embed::pwm, embed::timer\nPublic Functions     Name     bool initialize()Initialize the driver, apply the setting as defined in the settings_t structure and enable it. Calling this function after it has already been initialized will return false. In order to run initialization again, reset() must be called. After initialization, the settings are committed and saved into another settings structure. This settings can be looked up and inspected by the application.   void reset()Reset the driver in order to run initialize again. This is helpful if the application needs to change the settings of a driver after it is first initialized, like baud rate for serial or pull resistor for a pin.   bool is_initialized() constDetermine if the driver has been initialized.   settings_t \u0026 settings()Get access to uncommitted driver settings.   const settings_t \u0026 initialized_settings() constGet access to the settings that were used in the latest initialization. These settings only get updated when a successful initialize() has occurred.    Protected Functions     Name     virtual bool driver_initialize() =0    Protected Attributes     Name     settings_t m_settings   settings_t m_initialized_settings   bool m_initialized    Detailed Description template \u003cclass settings_t =no_settings\u003e class embed::driver; The basis class for all peripheral, device and system drivers in libembeddedhal.\nTemplate Parameters:\n settings_t generic settings for the driver. For example, generic settings for a uart driver would have baud rate, stop bits and parity. This is expected of all UART devices and as such is part of the systems API.  Public Functions Documentation function initialize inline bool initialize() Initialize the driver, apply the setting as defined in the settings_t structure and enable it. Calling this function after it has already been initialized will return false. In order to run initialization again, reset() must be called. After initialization, the settings are committed and saved into another settings structure. This settings can be looked up and inspected by the application.\nReturn:\n true - initialization of the driver was successful false - initialization of the driver failed. See the error() function for details about exactly what failed.  function reset inline void reset() Reset the driver in order to run initialize again. This is helpful if the application needs to change the settings of a driver after it is first initialized, like baud rate for serial or pull resistor for a pin.\nfunction is_initialized inline bool is_initialized() const Determine if the driver has been initialized.\nReturn:\n true the driver is initialized false the driver has not been initialized or has been reset  function settings inline settings_t \u0026 settings() Get access to uncommitted driver settings.\nReturn: settings_t\u0026 reference to the uncommitted driver settings. When initialize runs successful, the uncommitted settings will be saved to the initialize_settings().\nfunction initialized_settings inline const settings_t \u0026 initialized_settings() const Get access to the settings that were used in the latest initialization. These settings only get updated when a successful initialize() has occurred.\nReturn: const settings_t\u0026 the current settings of the driver if it is initialized. If the driver is not initialized, then the contents of this structure should be ignored as they may not represent the current of the driver.\nProtected Functions Documentation function driver_initialize virtual bool driver_initialize() =0 Reimplemented by: embed::can_network::driver_initialize\nProtected Attributes Documentation variable m_settings settings_t m_settings {}; variable m_initialized_settings settings_t m_initialized_settings {}; variable m_initialized bool m_initialized = false;  Updated on 2021-12-04 at 16:50:11 +0000\n","description":"","tags":null,"title":"embed::driver","uri":"/libembeddedhal/api/classes/classembed_1_1driver/"},{"content":"embed::full_scale Class Reference\nMore…\n#include \u003cfull_scale.hpp\u003e\nPublic Functions     Name     constexpr full_scale()   template \u003ctypename U ,size_t bit_width\u003e constexpr full_scale(bit_depth\u003c U, bit_width \u003e p_value)   template \u003ctypename U ,size_t bit_width\u003e constexpr full_scale\u003c T \u003e \u0026 operator=(bit_depth\u003c U, bit_width \u003e p_value)   T value()    Public Attributes     Name     constexpr size_t bit_width Calculate the number.    Detailed Description template \u003ctypename T \u003e class embed::full_scale; Template Parameters:\n T  Public Functions Documentation function full_scale inline constexpr full_scale() function full_scale template \u003ctypename U , size_t bit_width\u003e inline constexpr full_scale( bit_depth\u003c U, bit_width \u003e p_value ) function operator= template \u003ctypename U , size_t bit_width\u003e inline constexpr full_scale\u003c T \u003e \u0026 operator=( bit_depth\u003c U, bit_width \u003e p_value ) function value inline T value() Public Attributes Documentation variable bit_width static constexpr size_t bit_width = sizeof(T) * CHAR_BIT; Calculate the number.\n Updated on 2021-12-04 at 16:50:11 +0000\n","description":"","tags":null,"title":"embed::full_scale","uri":"/libembeddedhal/api/classes/classembed_1_1full__scale/"},{"content":"embed::i2c Class Reference\nInter-integrated Circuit (I2C) or Two Wire Interface (TWI) communication protocol hardware abstract interface.\n#include \u003ci2c.hpp\u003e\nInherits from embed::driver\u003c i2c_settings \u003e\nPublic Functions     Name     virtual void transaction(std::byte p_address, std::span\u003c const std::byte \u003e p_data_out, std::span\u003c std::byte \u003e p_data_in) =0perform an i2c transaction with another device on the bus. The type of transaction depends on values of input parameters.   virtual bool busy() =0Determines if the i2c transaction is ongoing.    Additional inherited members Public Functions inherited from embed::driver\u003c i2c_settings \u003e\n    Name     bool initialize()Initialize the driver, apply the setting as defined in the settings_t structure and enable it. Calling this function after it has already been initialized will return false. In order to run initialization again, reset() must be called. After initialization, the settings are committed and saved into another settings structure. This settings can be looked up and inspected by the application.   void reset()Reset the driver in order to run initialize again. This is helpful if the application needs to change the settings of a driver after it is first initialized, like baud rate for serial or pull resistor for a pin.   bool is_initialized() constDetermine if the driver has been initialized.   settings_t \u0026 settings()Get access to uncommitted driver settings.   const settings_t \u0026 initialized_settings() constGet access to the settings that were used in the latest initialization. These settings only get updated when a successful initialize() has occurred.    Protected Functions inherited from embed::driver\u003c i2c_settings \u003e\n    Name     virtual bool driver_initialize() =0    Protected Attributes inherited from embed::driver\u003c i2c_settings \u003e\n    Name     settings_t m_settings   settings_t m_initialized_settings   bool m_initialized    Public Functions Documentation function transaction virtual void transaction( std::byte p_address, std::span\u003c const std::byte \u003e p_data_out, std::span\u003c std::byte \u003e p_data_in ) =0 perform an i2c transaction with another device on the bus. The type of transaction depends on values of input parameters.\nParameters:\n p_address 7-bit address of the device you want to communicate with. To perform a transaction with a 10-bit address, this parameter must be the address upper byte of the 10-bit address OR’d with 0b1111'0000 (the 10-bit address indicator). The lower byte of the address must be contained in the first byte of the p_data_out span. p_data_out data to be written to the addressed device. Set to nullptr with length zero in order to skip writting. p_data_in buffer to store read data from the addressed device. Set to nullptr with length 0 in order to skip reading.  Performing Write, Read and Write-Then-Read transactions depends on which span for data_out and data_in are set to null.\n For write transactions, pass p_data_in as an empty span std::span\u003cstd::byte\u003e{} and pass a buffer to p_data_out. For read transactions, pass p_data_out as an empty span std::span\u003cconst std::byte\u003e{} and pass a buffer to p_data_in. For write-then-read transactions, pass a buffer for both p_data_in p_data_out. Implementations of transaction can be synchronous, interrupt driven or DMA driven. Calling transaction while a current transaction is ongoing is undefined behavior. To prevent this, poll busy() until it returns false.  function busy virtual bool busy() =0 Determines if the i2c transaction is ongoing.\nReturn:\n true transaction is currently ongoing false device is idle and available for a transaction   Updated on 2021-12-04 at 16:50:11 +0000\n","description":"","tags":null,"title":"embed::i2c","uri":"/libembeddedhal/api/classes/classembed_1_1i2c/"},{"content":"embed::i2c_settings Struct Reference\nGeneric settings for a standard I2C device.\n#include \u003ci2c.hpp\u003e\nPublic Attributes     Name     uint32_t clock_rate_hz The serial clock rate in hertz.    Public Attributes Documentation variable clock_rate_hz uint32_t clock_rate_hz = 100'000; The serial clock rate in hertz.\n Updated on 2021-12-04 at 16:50:11 +0000\n","description":"","tags":null,"title":"embed::i2c_settings","uri":"/libembeddedhal/api/classes/structembed_1_1i2c__settings/"},{"content":"embed::input_pin Class Reference\nDigital input pin hardware abstraction. Use this to read a pin and determine if the voltage on it is HIGH or LOW.\n#include \u003cgpio.hpp\u003e\nInherits from embed::driver\u003c input_pin_settings \u003e\nPublic Functions     Name     virtual bool level() const =0Read the state of the input pin.    Additional inherited members Public Functions inherited from embed::driver\u003c input_pin_settings \u003e\n    Name     bool initialize()Initialize the driver, apply the setting as defined in the settings_t structure and enable it. Calling this function after it has already been initialized will return false. In order to run initialization again, reset() must be called. After initialization, the settings are committed and saved into another settings structure. This settings can be looked up and inspected by the application.   void reset()Reset the driver in order to run initialize again. This is helpful if the application needs to change the settings of a driver after it is first initialized, like baud rate for serial or pull resistor for a pin.   bool is_initialized() constDetermine if the driver has been initialized.   settings_t \u0026 settings()Get access to uncommitted driver settings.   const settings_t \u0026 initialized_settings() constGet access to the settings that were used in the latest initialization. These settings only get updated when a successful initialize() has occurred.    Protected Functions inherited from embed::driver\u003c input_pin_settings \u003e\n    Name     virtual bool driver_initialize() =0    Protected Attributes inherited from embed::driver\u003c input_pin_settings \u003e\n    Name     settings_t m_settings   settings_t m_initialized_settings   bool m_initialized    Public Functions Documentation function level virtual bool level() const =0 Read the state of the input pin.\nReturn:\n true indicates a HIGH voltage false indicates a LOW voltage   Updated on 2021-12-04 at 16:50:11 +0000\n","description":"","tags":null,"title":"embed::input_pin","uri":"/libembeddedhal/api/classes/classembed_1_1input__pin/"},{"content":"embed::input_pin_settings Struct Reference\nGeneric settings for input pins.\n#include \u003cgpio.hpp\u003e\nPublic Attributes     Name     pin_resistor resistor pull resistor for an input pin    Public Attributes Documentation variable resistor pin_resistor resistor = pin_resistor::pull_up; pull resistor for an input pin\n Updated on 2021-12-04 at 16:50:11 +0000\n","description":"","tags":null,"title":"embed::input_pin_settings","uri":"/libembeddedhal/api/classes/structembed_1_1input__pin__settings/"},{"content":"embed::interrupt_pin Class Reference\nDigital interrupt pin hardware abstraction. Use this to trigger an interrupt service routine (ISR) when a pin detects a falling edge (when the pin’s voltage transitions from HIGH to LOW), a rising edge (when the pin’s voltage transitions from LOW to HIGH), or any transition of state on the pin.\n#include \u003cgpio.hpp\u003e\nInherits from embed::driver\u003c interrupt_pin_settings \u003e\nPublic Types     Name     enum class trigger_edge { falling = 0, rising = 1, both = 2}The condition in which an interrupt is triggered.    Public Functions     Name     virtual bool level() const =0Return the voltage level of the pin.   virtual void attach_interrupt(std::function\u003c void(void)\u003e p_callback, trigger_edge p_trigger) =0Enable interrupts for this pin. Pass in the callback to be executed when the trigger condition is met. This function can be called multiple times if the callback or trigger conditions need to be changed. detach_interrupts() does not need to be called before re-running this function.   virtual void detach_interrupt() =0Disable interrupts for this pin.    Additional inherited members Public Functions inherited from embed::driver\u003c interrupt_pin_settings \u003e\n    Name     bool initialize()Initialize the driver, apply the setting as defined in the settings_t structure and enable it. Calling this function after it has already been initialized will return false. In order to run initialization again, reset() must be called. After initialization, the settings are committed and saved into another settings structure. This settings can be looked up and inspected by the application.   void reset()Reset the driver in order to run initialize again. This is helpful if the application needs to change the settings of a driver after it is first initialized, like baud rate for serial or pull resistor for a pin.   bool is_initialized() constDetermine if the driver has been initialized.   settings_t \u0026 settings()Get access to uncommitted driver settings.   const settings_t \u0026 initialized_settings() constGet access to the settings that were used in the latest initialization. These settings only get updated when a successful initialize() has occurred.    Protected Functions inherited from embed::driver\u003c interrupt_pin_settings \u003e\n    Name     virtual bool driver_initialize() =0    Protected Attributes inherited from embed::driver\u003c interrupt_pin_settings \u003e\n    Name     settings_t m_settings   settings_t m_initialized_settings   bool m_initialized    Public Types Documentation enum trigger_edge    Enumerator Value Description     falling 0 Trigger and interrupt when a pin transitions from HIGH voltage to LOW voltage.   rising 1 Trigger and interrupt when a pin transitions from LOW voltage to HIGH voltage.   both 2 Trigger and interrupt when a pin transitions it state.    The condition in which an interrupt is triggered.\nPublic Functions Documentation function level virtual bool level() const =0 Return the voltage level of the pin.\nReturn:\n true HIGH voltage false LOW voltage  function attach_interrupt virtual void attach_interrupt( std::function\u003c void(void)\u003e p_callback, trigger_edge p_trigger ) =0 Enable interrupts for this pin. Pass in the callback to be executed when the trigger condition is met. This function can be called multiple times if the callback or trigger conditions need to be changed. detach_interrupts() does not need to be called before re-running this function.\nParameters:\n p_callback function to execute when the trigger condition is met p_trigger the trigger condition that will signal the system to run the callback.  function detach_interrupt virtual void detach_interrupt() =0 Disable interrupts for this pin.\n Updated on 2021-12-04 at 16:50:11 +0000\n","description":"","tags":null,"title":"embed::interrupt_pin","uri":"/libembeddedhal/api/classes/classembed_1_1interrupt__pin/"},{"content":"embed::interrupt_pin_settings Struct Reference\nGeneric settings for interrupt pins.\n#include \u003cgpio.hpp\u003e\nPublic Attributes     Name     pin_resistor resistor pull resistor for an interrupt pin. Generally advised to NOT use [pin_resistor::none](namespaces/namespaceembed/#enumvalue-none) and if it is used and external pull resistor should be placed on the pin to prevent random interrupt from firing.    Public Attributes Documentation variable resistor pin_resistor resistor = pin_resistor::pull_up; pull resistor for an interrupt pin. Generally advised to NOT use [pin_resistor::none](namespaces/namespaceembed/#enumvalue-none) and if it is used and external pull resistor should be placed on the pin to prevent random interrupt from firing.\n Updated on 2021-12-04 at 16:50:11 +0000\n","description":"","tags":null,"title":"embed::interrupt_pin_settings","uri":"/libembeddedhal/api/classes/structembed_1_1interrupt__pin__settings/"},{"content":"embed::invalid_option_t Struct Reference\nUsed for defining static_asserts that should always fail, but only if the static_assert line is hit via if constexpr control block. Prefer to NOT use this directly but to use invalid_option instead. More…\n#include \u003cdriver.hpp\u003e\nInherits from std::false_type\nDetailed Description template \u003cauto... options\u003e struct embed::invalid_option_t; Used for defining static_asserts that should always fail, but only if the static_assert line is hit via if constexpr control block. Prefer to NOT use this directly but to use invalid_option instead.\nTemplate Parameters:\n options ignored by the application but needed to create a non-trivial specialization of this class which allows its usage in static_assert.   Updated on 2021-12-04 at 16:50:11 +0000\n","description":"","tags":null,"title":"embed::invalid_option_t","uri":"/libembeddedhal/api/classes/structembed_1_1invalid__option__t/"},{"content":"embed::no_settings Struct Reference\nAn empty settings structure used to indicate that a driver or interface does not have generic settings.\n#include \u003cdriver.hpp\u003e\n Updated on 2021-12-04 at 16:50:11 +0000\n","description":"","tags":null,"title":"embed::no_settings","uri":"/libembeddedhal/api/classes/structembed_1_1no__settings/"},{"content":"embed::output_pin Class Reference\nDigital output pin hardware abstraction. Use this to drive a pin HIGH or LOW in order to send a control signal or turn off or on an LED.\n#include \u003cgpio.hpp\u003e\nInherits from embed::driver\u003c output_pin_settings \u003e\nPublic Functions     Name     virtual void level(bool p_high) =0Set the state of the pin.   virtual bool level() const =0Read the state of the input pin. Implementations must read the pin state from hardware and will not simply cache the results from running level(bool).    Additional inherited members Public Functions inherited from embed::driver\u003c output_pin_settings \u003e\n    Name     bool initialize()Initialize the driver, apply the setting as defined in the settings_t structure and enable it. Calling this function after it has already been initialized will return false. In order to run initialization again, reset() must be called. After initialization, the settings are committed and saved into another settings structure. This settings can be looked up and inspected by the application.   void reset()Reset the driver in order to run initialize again. This is helpful if the application needs to change the settings of a driver after it is first initialized, like baud rate for serial or pull resistor for a pin.   bool is_initialized() constDetermine if the driver has been initialized.   settings_t \u0026 settings()Get access to uncommitted driver settings.   const settings_t \u0026 initialized_settings() constGet access to the settings that were used in the latest initialization. These settings only get updated when a successful initialize() has occurred.    Protected Functions inherited from embed::driver\u003c output_pin_settings \u003e\n    Name     virtual bool driver_initialize() =0    Protected Attributes inherited from embed::driver\u003c output_pin_settings \u003e\n    Name     settings_t m_settings   settings_t m_initialized_settings   bool m_initialized    Public Functions Documentation function level virtual void level( bool p_high ) =0 Set the state of the pin.\nParameters:\n p_high if true then the pin state is set to HIGH voltage. If false, the pin state is set to LOW voltage.  function level virtual bool level() const =0 Read the state of the input pin. Implementations must read the pin state from hardware and will not simply cache the results from running level(bool).\nReturn:\n true indicates a HIGH voltage false indicates a LOW voltage   Updated on 2021-12-04 at 16:50:11 +0000\n","description":"","tags":null,"title":"embed::output_pin","uri":"/libembeddedhal/api/classes/classembed_1_1output__pin/"},{"content":"embed::output_pin_settings Struct Reference\nGeneric settings for output pins.\n#include \u003cgpio.hpp\u003e\nPublic Attributes     Name     bool starting_level Set the starting level of the output pin on initialization. HIGH voltage defined as true and LOW voltage defined as false.   bool open_drain Starting level of the output pin. HIGH voltage defined as true and LOW voltage defined as false.   pin_resistor resistor Pull resistor for the pin. This generally only helpful when open drain is enabled.    Public Attributes Documentation variable starting_level bool starting_level = true; Set the starting level of the output pin on initialization. HIGH voltage defined as true and LOW voltage defined as false.\nvariable open_drain bool open_drain = false; Starting level of the output pin. HIGH voltage defined as true and LOW voltage defined as false.\nvariable resistor pin_resistor resistor = pin_resistor::pull_up; Pull resistor for the pin. This generally only helpful when open drain is enabled.\n Updated on 2021-12-04 at 16:50:11 +0000\n","description":"","tags":null,"title":"embed::output_pin_settings","uri":"/libembeddedhal/api/classes/structembed_1_1output__pin__settings/"},{"content":"embed::pwm Class Reference\nPulse Width Modulation (PWM) channel hardware abstraction.\n#include \u003cpwm.hpp\u003e\nInherits from embed::driver\u003c\u003e\nAdditional inherited members Public Functions inherited from embed::driver\u003c\u003e\n    Name     bool initialize()Initialize the driver, apply the setting as defined in the settings_t structure and enable it. Calling this function after it has already been initialized will return false. In order to run initialization again, reset() must be called. After initialization, the settings are committed and saved into another settings structure. This settings can be looked up and inspected by the application.   void reset()Reset the driver in order to run initialize again. This is helpful if the application needs to change the settings of a driver after it is first initialized, like baud rate for serial or pull resistor for a pin.   bool is_initialized() constDetermine if the driver has been initialized.   settings_t \u0026 settings()Get access to uncommitted driver settings.   const settings_t \u0026 initialized_settings() constGet access to the settings that were used in the latest initialization. These settings only get updated when a successful initialize() has occurred.    Protected Functions inherited from embed::driver\u003c\u003e\n    Name     virtual bool driver_initialize() =0    Protected Attributes inherited from embed::driver\u003c\u003e\n    Name     settings_t m_settings   settings_t m_initialized_settings   bool m_initialized     Updated on 2021-12-04 at 16:50:11 +0000\n","description":"","tags":null,"title":"embed::pwm","uri":"/libembeddedhal/api/classes/classembed_1_1pwm/"},{"content":"embed::serial Class Reference\nSerial communication protocol hardware abstract interface. Use this interface for hardware that implements a serial protocol like UART, USART, RS232, RS485 and many others that use a similar communication protocol but may use different voltage schemes. More…\n#include \u003cserial.hpp\u003e\nInherits from embed::driver\u003c serial_settings \u003e\nPublic Functions     Name     virtual void write(std::span\u003c const std::byte \u003e p_data) =0Write data on the transmitter line of the port. The exact implementation for this can be polling, interrupt driven or DMA driven. There is no guarantee on exactly how a write operation will operate, thus the busy() function must polled called after this returns to determine if the write operation has finished. Attempting to call write() when tranmission is busy is undefined behavior.   virtual bool busy() =0Determines if the write operation is currently on going.   virtual size_t bytes_available() =0The number of bytes that have been buffered. For frames less than 8-bits, each byte holds a frame. For frames above 8-bits the number of bytes returned indicates the number of bytes a buffer needs to be to return all of the data held in the buffer.   virtual std::span\u003c const std::byte \u003e read(std::span\u003c std::byte \u003e p_data) =0Read the bytes received over the ports receiver line and stored in the serial implementations buffer. The number of bytes read will subtract the number of bytes available until it reaches zero.   virtual void flush() =0Set bytes_available() to zero and clear any received data stored in hardware registers. This operation must be faster than simply running read() until bytes_available() is empty.    Additional inherited members Public Functions inherited from embed::driver\u003c serial_settings \u003e\n    Name     bool initialize()Initialize the driver, apply the setting as defined in the settings_t structure and enable it. Calling this function after it has already been initialized will return false. In order to run initialization again, reset() must be called. After initialization, the settings are committed and saved into another settings structure. This settings can be looked up and inspected by the application.   void reset()Reset the driver in order to run initialize again. This is helpful if the application needs to change the settings of a driver after it is first initialized, like baud rate for serial or pull resistor for a pin.   bool is_initialized() constDetermine if the driver has been initialized.   settings_t \u0026 settings()Get access to uncommitted driver settings.   const settings_t \u0026 initialized_settings() constGet access to the settings that were used in the latest initialization. These settings only get updated when a successful initialize() has occurred.    Protected Functions inherited from embed::driver\u003c serial_settings \u003e\n    Name     virtual bool driver_initialize() =0    Protected Attributes inherited from embed::driver\u003c serial_settings \u003e\n    Name     settings_t m_settings   settings_t m_initialized_settings   bool m_initialized    Detailed Description class embed::serial; Serial communication protocol hardware abstract interface. Use this interface for hardware that implements a serial protocol like UART, USART, RS232, RS485 and many others that use a similar communication protocol but may use different voltage schemes.\nDue to the asynchronous nature of serial communication protocols, all implementations of serial devices MUST buffer received bytes using DMA or interrupts. A thread should not be used as this generally greatly increases the ROM and RAM cost of using library.\nAll implementations MUST allow the user to supply their own buffer of arbitrary size, such that the amount of buffered data can be tailored to the needs of the application.\nPublic Functions Documentation function write virtual void write( std::span\u003c const std::byte \u003e p_data ) =0 Write data on the transmitter line of the port. The exact implementation for this can be polling, interrupt driven or DMA driven. There is no guarantee on exactly how a write operation will operate, thus the busy() function must polled called after this returns to determine if the write operation has finished. Attempting to call write() when tranmission is busy is undefined behavior.\nParameters:\n p_data data to be transmitted over the serial port transmitter line  Data frames are not compact when frame size is less than 8 bits. Meaning that, if you want to send three 5-bit frames, then you will need to use a span of at least 3 bytes to hold each value.\nWhen writing data with frame size greater than 8 is in little endian order. Meaning that the first byte in the sequence is the lower byte and the next is the greater byte. If you wanted to send a 9-bit frame with value 0x14A, the first byte must be 0x4A and the next 0x01.\nfunction busy virtual bool busy() =0 Determines if the write operation is currently on going.\nReturn:\n true serial transmitter is currently writing data to the port false serial transmitter is idle and available to write data  function bytes_available virtual size_t bytes_available() =0 The number of bytes that have been buffered. For frames less than 8-bits, each byte holds a frame. For frames above 8-bits the number of bytes returned indicates the number of bytes a buffer needs to be to return all of the data held in the buffer.\nReturn: size_t number of buffered by the serial driver and are available to be read by the read() function.\nfunction read virtual std::span\u003c const std::byte \u003e read( std::span\u003c std::byte \u003e p_data ) =0 Read the bytes received over the ports receiver line and stored in the serial implementations buffer. The number of bytes read will subtract the number of bytes available until it reaches zero.\nParameters:\n p_data Buffer to read bytes back from. If the length of this buffer is greater than the value returned by bytes_available() then buffer is filled up to the length returned by bytes_available(). The rest of the buffer is left untouched.  Return: std::spanprovides a means to get the length of bytes read into the buffer p_data. The address will ALWAYS be the same as p_data and the length will be equal to the number of bytes read from the buffer.\nfunction flush virtual void flush() =0 Set bytes_available() to zero and clear any received data stored in hardware registers. This operation must be faster than simply running read() until bytes_available() is empty.\n Updated on 2021-12-04 at 16:50:11 +0000\n","description":"","tags":null,"title":"embed::serial","uri":"/libembeddedhal/api/classes/classembed_1_1serial/"},{"content":"embed::serial_settings Struct Reference\nGeneric settings for a standard serial device.\n#include \u003cserial.hpp\u003e\nPublic Types     Name     enum class uint8_t stop_bits { one = 0, two}Set of available stop bits options.   enum class uint8_t parity { none = 0, odd, even, forced1, forced0}Set of parity bit options.    Public Attributes     Name     uint32_t baud_rate The operating speed of the baud rate (in units of bits per second)   parity parity Parity bit type for each frame.   stop_bits stop Number of stop bits for each frame.   uint8_t frame_size Number of bits in each frame. Typically between 5 to 9.    Public Types Documentation enum stop_bits    Enumerator Value Description     one 0    two      Set of available stop bits options.\nenum parity    Enumerator Value Description     none 0 Disable parity bit as part of the frame.   odd  Enable parity and set 1 (HIGH) when the number of bits is odd.   even  Enable parity and set 1 (HIGH) when the number of bits is even.   forced1  Enable parity bit and always return 1 (HIGH) for ever frame.   forced0  Enable parity bit and always return 0 (LOW) for ever frame.    Set of parity bit options.\nPublic Attributes Documentation variable baud_rate uint32_t baud_rate = 115200; The operating speed of the baud rate (in units of bits per second)\nvariable parity parity parity = parity::none; Parity bit type for each frame.\nvariable stop stop_bits stop = stop_bits::one; Number of stop bits for each frame.\nvariable frame_size uint8_t frame_size = 8; Number of bits in each frame. Typically between 5 to 9.\n Updated on 2021-12-04 at 16:50:11 +0000\n","description":"","tags":null,"title":"embed::serial_settings","uri":"/libembeddedhal/api/classes/structembed_1_1serial__settings/"},{"content":"embed::spi Class Reference\nSerial peripheral interface (SPI) communication protocol hardware abstract interface.\n#include \u003cspi.hpp\u003e\nInherits from embed::driver\u003c spi_settings \u003e\nPublic Functions     Name     virtual bool busy() =0Determines if a transfer is currently ongoing.   virtual void transfer(std::span\u003c const std::byte \u003e p_data_out, std::span\u003c std::byte \u003e p_data_in, std::byte p_write_value =std::byte{ 0xFF }) =0Send and receieve bytes from the spi bus.    Additional inherited members Public Functions inherited from embed::driver\u003c spi_settings \u003e\n    Name     bool initialize()Initialize the driver, apply the setting as defined in the settings_t structure and enable it. Calling this function after it has already been initialized will return false. In order to run initialization again, reset() must be called. After initialization, the settings are committed and saved into another settings structure. This settings can be looked up and inspected by the application.   void reset()Reset the driver in order to run initialize again. This is helpful if the application needs to change the settings of a driver after it is first initialized, like baud rate for serial or pull resistor for a pin.   bool is_initialized() constDetermine if the driver has been initialized.   settings_t \u0026 settings()Get access to uncommitted driver settings.   const settings_t \u0026 initialized_settings() constGet access to the settings that were used in the latest initialization. These settings only get updated when a successful initialize() has occurred.    Protected Functions inherited from embed::driver\u003c spi_settings \u003e\n    Name     virtual bool driver_initialize() =0    Protected Attributes inherited from embed::driver\u003c spi_settings \u003e\n    Name     settings_t m_settings   settings_t m_initialized_settings   bool m_initialized    Public Functions Documentation function busy virtual bool busy() =0 Determines if a transfer is currently ongoing.\nReturn:\n true transfer is currently ongoing false device is idle and available for a transaction  function transfer virtual void transfer( std::span\u003c const std::byte \u003e p_data_out, std::span\u003c std::byte \u003e p_data_in, std::byte p_write_value =std::byte{ 0xFF } ) =0 Send and receieve bytes from the spi bus.\nParameters:\n p_data_out buffer to write data to the bus. If this is set to null/empty then writing is ignored and the p_write_value will be written to the bus. If the length is less than p_data_in, then p_write_value will be written to the bus after this buffer has been sent. p_data_in buffer to read the data off of the bus. If this is null/empty, then the transfer will be write only and the incoming data will be ignored. If the length of this buffer is less than p_data_out, once this buffer has been filled, the rest of the received bytes on the bus will be dropped. p_write_value filler data to be placed on the bus when the p_data_out buffer has been exhausted.   Updated on 2021-12-04 at 16:50:11 +0000\n","description":"","tags":null,"title":"embed::spi","uri":"/libembeddedhal/api/classes/classembed_1_1spi/"},{"content":"embed::spi_settings Struct Reference\nGeneric settings for a standard SPI device.\n#include \u003cspi.hpp\u003e\nPublic Attributes     Name     uint32_t clock_rate_hz Serial clock frequency.   bool clock_idles_high The polarity of the pins when the signal is idle.   bool data_valid_on_trailing_edge The phase of the clock signal when communicating.    Public Attributes Documentation variable clock_rate_hz uint32_t clock_rate_hz = 100'000; Serial clock frequency.\nvariable clock_idles_high bool clock_idles_high = false; The polarity of the pins when the signal is idle.\nvariable data_valid_on_trailing_edge bool data_valid_on_trailing_edge = false; The phase of the clock signal when communicating.\n Updated on 2021-12-04 at 16:50:11 +0000\n","description":"","tags":null,"title":"embed::spi_settings","uri":"/libembeddedhal/api/classes/structembed_1_1spi__settings/"},{"content":"embed::static_callable Class Reference\nGeneral class which will be used to allow for signature to be used and then split by the below class. More…\nDetailed Description template \u003cclass owner_class , int reference_designator, typename signature \u003e class embed::static_callable; General class which will be used to allow for signature to be used and then split by the below class.\nTemplate Parameters:\n owner_class reference_designator signature   Updated on 2021-12-04 at 16:50:11 +0000\n","description":"","tags":null,"title":"embed::static_callable","uri":"/libembeddedhal/api/classes/classembed_1_1static__callable/"},{"content":"embed::static_callable\u003c owner_class, reference_designator, return_t(args_t…)\u003e Class Reference\nSpecialization of static_callable with the return type and arguments split up. More…\n#include \u003cstatic_callable.hpp\u003e\nPublic Functions     Name      static_callable(std::function\u003c return_t(args_t…)\u003e p_callback)Construct a new static callable object.   auto * get_handler()Get the handler object.    Detailed Description template \u003cclass owner_class , int reference_designator, typename return_t , typename... args_t\u003e class embed::static_callable\u003c owner_class, reference_designator, return_t(args_t...)\u003e; Specialization of static_callable with the return type and arguments split up.\nTemplate Parameters:\n owner_class see static_callable reference_designator see static_callable return_t args_t  Public Functions Documentation function static_callable inline static_callable( std::function\u003c return_t(args_t...)\u003e p_callback ) Construct a new static callable object.\nParameters:\n p_callback  function get_handler inline auto * get_handler() Get the handler object.\nReturn: auto*\n Updated on 2021-12-04 at 16:50:11 +0000\n","description":"","tags":null,"title":"embed::static_callable\u003c owner_class, reference_designator, return_t(args_t...)\u003e","uri":"/libembeddedhal/api/classes/classembed_1_1static__callable_3_01owner__class_00_01reference__designator_00_01return__t_07args__t_8_8_8_08_4/"},{"content":"embed::static_memory_resource Class Reference\nThe static_memory_resource is the polymorphic memory resource allocator that allows libembeddedhal’s libraries to use a C++ standard container such as std::pmr::vector, std::pmr::string, std::pmr::unordered_map, and more without requiring dynamic memory allocation from the heap. It provides a simple way to create an allocator with built in storage, with its size indicated by a single template parameter. It also provides statistics regarding the amount of memory allocated such that developers can determine if they need to reduce or increase the size of the buffer. Memory statistics can also give programs the insight into how much memory space is available and make decisions based on that. In the event that the memory of the static allocator is exceeded, a std::bad_alloc excpetion is thrown. More…\n#include \u003cstatic_memory_resource.hpp\u003e\nInherits from std::pmr::memory_resource\nPublic Functions     Name      static_memory_resource()   constexpr std::size_t capacity() const   std::size_t memory_used() const   int memory_available() const    Protected Functions     Name     void * do_allocate(std::size_t bytes, std::size_t alignment) overrideImplemenation of the do_allocate() method for std::pmr::memory_resource.   void do_deallocate(void * address, std::size_t bytes, std::size_t alignment) overrideImplemenation of the do_deallocate() method for std::pmr::memory_resource.   bool do_is_equal(const std::pmr::memory_resource \u0026 other) const overrideImplemenation of the do_is_equal() method for std::pmr::memory_resource.    Detailed Description template \u003csize_t BufferSize\u003e class embed::static_memory_resource; The static_memory_resource is the polymorphic memory resource allocator that allows libembeddedhal’s libraries to use a C++ standard container such as std::pmr::vector, std::pmr::string, std::pmr::unordered_map, and more without requiring dynamic memory allocation from the heap. It provides a simple way to create an allocator with built in storage, with its size indicated by a single template parameter. It also provides statistics regarding the amount of memory allocated such that developers can determine if they need to reduce or increase the size of the buffer. Memory statistics can also give programs the insight into how much memory space is available and make decisions based on that. In the event that the memory of the static allocator is exceeded, a std::bad_alloc excpetion is thrown.\nTemplate Parameters:\n BufferSize number of bytes to statically allocate for the memory resource.  USAGE:\n// Make a memory resource with 1kB buffer static_memory_resource\u003c1024\u003e memory_resource; std::pmr::unordered_map\u003cint, const char*\u003e id_name_map(\u0026memory_resource);\nPublic Functions Documentation function static_memory_resource inline static_memory_resource() function capacity inline constexpr std::size_t capacity() const Return: constexpr std::size_t - the total number of bytes that this allocator can allocate before throwing a std::bad_alloc exception.\nfunction memory_used inline std::size_t memory_used() const Return: std::size_t number of bytes that have already been allocated.\nfunction memory_available inline int memory_available() const Return: int Bytes that have yet to be allocated from this allocator.\nProtected Functions Documentation function do_allocate inline void * do_allocate( std::size_t bytes, std::size_t alignment ) override Implemenation of the do_allocate() method for std::pmr::memory_resource.\nParameters:\n bytes number of bytes to allocate alignment alignment limit for the allocation  Return: void* address of the newly allocated buffer\nfunction do_deallocate inline void do_deallocate( void * address, std::size_t bytes, std::size_t alignment ) override Implemenation of the do_deallocate() method for std::pmr::memory_resource.\nParameters:\n address address of space to be deallocated bytes number of bytes to allocate alignment alignment limit for the allocation  function do_is_equal inline bool do_is_equal( const std::pmr::memory_resource \u0026 other ) const override Implemenation of the do_is_equal() method for std::pmr::memory_resource.\nParameters:\n other another memory resource to  Return:\n true are equal false are not equal   Updated on 2021-12-04 at 16:50:11 +0000\n","description":"","tags":null,"title":"embed::static_memory_resource","uri":"/libembeddedhal/api/classes/classembed_1_1static__memory__resource/"},{"content":"embed::this_thread Namespace Reference\nClasses     Name     struct embed::this_thread::global_clocks internal clock    Types     Name     using std::chrono::nanoseconds time_increment smallest increment of time for clocks   using std::function\u003c void(std::chrono::nanoseconds)\u003e sleep_function definition of a sleep function   using std::function\u003c std::chrono::nanoseconds(void)\u003e uptime_function definition of an uptime function    Functions     Name     auto sleep_for(time_increment delay)Delay execution of the program by a predefined time.   auto uptime()Get the current system uptime.   void set_global_sleep(sleep_function sleep_function)Set the global sleep object.   void set_global_uptime(uptime_function uptime_function)Set the global uptime object.    Types Documentation using time_increment using embed::this_thread::time_increment = typedef std::chrono::nanoseconds; smallest increment of time for clocks\nusing sleep_function using embed::this_thread::sleep_function = typedef std::function\u003cvoid(std::chrono::nanoseconds)\u003e; definition of a sleep function\nusing uptime_function using embed::this_thread::uptime_function = typedef std::function\u003cstd::chrono::nanoseconds(void)\u003e; definition of an uptime function\nFunctions Documentation function sleep_for static auto sleep_for( time_increment delay ) Delay execution of the program by a predefined time.\nParameters:\n delay the amount of time to delay execution by  function uptime static auto uptime() Get the current system uptime.\nReturn: auto the global uptime\nfunction set_global_sleep static void set_global_sleep( sleep_function sleep_function ) Set the global sleep object.\nParameters:\n sleep_function the function to handle sleeping  function set_global_uptime static void set_global_uptime( uptime_function uptime_function ) Set the global uptime object.\nParameters:\n uptime_function the function to return the current system uptime   Updated on 2021-12-04 at 16:50:11 +0000\n","description":"","tags":null,"title":"embed::this_thread","uri":"/libembeddedhal/api/namespaces/namespaceembed_1_1this__thread/"},{"content":"embed::this_thread::global_clocks Struct Reference\ninternal clock\n#include \u003cclock.hpp\u003e\nPublic Attributes     Name     auto m_incremental_uptime Default uptime timer that simply counts each time it is called. This should almost never be used.   auto m_loop_delay Default sleep function that simply counts until it reaches a designated number.   sleep_function m_global_sleep Store the global sleep function.   uptime_function m_global_uptime Store the global uptime function.    Public Attributes Documentation variable m_incremental_uptime static auto m_incremental_uptime = []() -\u003e time_increment { using namespace std::chrono_literals; static time_increment count{ 0 }; count += 100ns; return count; }; Default uptime timer that simply counts each time it is called. This should almost never be used.\nvariable m_loop_delay static auto m_loop_delay = [](time_increment loop_count) { time_increment count{ 0 }; while (count \u003c loop_count) { count += std::chrono::microseconds{ 100 }; } }; Default sleep function that simply counts until it reaches a designated number.\nvariable m_global_sleep static sleep_function m_global_sleep = m_loop_delay; Store the global sleep function.\nvariable m_global_uptime static uptime_function m_global_uptime = m_incremental_uptime; Store the global uptime function.\n Updated on 2021-12-04 at 16:50:11 +0000\n","description":"","tags":null,"title":"embed::this_thread::global_clocks","uri":"/libembeddedhal/api/classes/structembed_1_1this__thread_1_1global__clocks/"},{"content":"embed::timer Class Reference\nTimer hardware abstraction interface. Use this interface for devices and peripherals that have timer like capabilities, such that, when a timer’s time has expired, an event/interrupt/signal is generated.\n#include \u003ctimer.hpp\u003e\nInherits from embed::driver\u003c\u003e\nPublic Types     Name     enum class controls { start, stop, reset}Set of controls for a timer.   enum class type { oneshot, continuous}Type of timer.    Public Functions     Name     virtual bool is_running() =0Determine if the timer is currently running.   virtual void control(controls p_control) =0Control the state of the timer.   virtual bool attach_interrupt(std::function\u003c void(void)\u003e p_callback, std::chrono::nanoseconds interval, type p_type =type::continuous) =0Setup the timer and attach an interrupt to it.    Additional inherited members Public Functions inherited from embed::driver\u003c\u003e\n    Name     bool initialize()Initialize the driver, apply the setting as defined in the settings_t structure and enable it. Calling this function after it has already been initialized will return false. In order to run initialization again, reset() must be called. After initialization, the settings are committed and saved into another settings structure. This settings can be looked up and inspected by the application.   void reset()Reset the driver in order to run initialize again. This is helpful if the application needs to change the settings of a driver after it is first initialized, like baud rate for serial or pull resistor for a pin.   bool is_initialized() constDetermine if the driver has been initialized.   settings_t \u0026 settings()Get access to uncommitted driver settings.   const settings_t \u0026 initialized_settings() constGet access to the settings that were used in the latest initialization. These settings only get updated when a successful initialize() has occurred.    Protected Functions inherited from embed::driver\u003c\u003e\n    Name     virtual bool driver_initialize() =0    Protected Attributes inherited from embed::driver\u003c\u003e\n    Name     settings_t m_settings   settings_t m_initialized_settings   bool m_initialized    Public Types Documentation enum controls    Enumerator Value Description     start  Control value to start the timer.   stop  Control value to stop a timer.   reset  Control value to reset a timer. The timer shall remain in a running or stopped state after this call. So an ongoing timer will continue to count but will have its counter reset to zero if this control is used. If a timer is stopped, then it shall be reset to zero, and stay stopped.    Set of controls for a timer.\nenum type    Enumerator Value Description     oneshot  Once the timer’s time has been reached an interrupt will fire and the timer will be stopped.   continuous  Once the timer’s time has been reached an interrupt will fire and the timer will be reset and will begin counting again.    Type of timer.\nPublic Functions Documentation function is_running virtual bool is_running() =0 Determine if the timer is currently running.\nReturn:\n true timer is currently running false timer is currently stopped  function control virtual void control( controls p_control ) =0 Control the state of the timer.\nParameters:\n p_control new state for the timer  function attach_interrupt virtual bool attach_interrupt( std::function\u003c void(void)\u003e p_callback, std::chrono::nanoseconds interval, type p_type =type::continuous ) =0 Setup the timer and attach an interrupt to it.\nParameters:\n p_callback callback function to be called when the timer expires interval the amount of time before the timer expires p_type the type of timer this is  Return:\n true successfully set all parameters false not all parameters could be met such as an interval smaller than is capable by hardware or an unsupported timer type.  When called this will, stop and reset the timer. To start the timer, control(controls::start) must be called.\n Updated on 2021-12-04 at 16:50:11 +0000\n","description":"","tags":null,"title":"embed::timer","uri":"/libembeddedhal/api/classes/classembed_1_1timer/"},{"content":" Updated on 2021-12-04 at 16:50:11 +0000\n","description":"","tags":null,"title":"Modules","uri":"/libembeddedhal/api/modules/"},{"content":" namespace embed  namespace this_thread     Updated on 2021-12-04 at 16:50:11 +0000\n","description":"","tags":null,"title":"Namespaces","uri":"/libembeddedhal/api/namespaces/"},{"content":" Updated on 2021-12-04 at 16:50:11 +0000\n","description":"","tags":null,"title":"Pages","uri":"/libembeddedhal/api/pages/"},{"content":"","description":"","tags":null,"title":"Tags","uri":"/libembeddedhal/tags/"}]