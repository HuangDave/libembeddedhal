<?xml version='1.0' encoding='UTF-8' standalone='no'?>
<doxygen xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xsi:noNamespaceSchemaLocation="compound.xsd" version="1.9.1" xml:lang="en-US">
  <compounddef id="classembed_1_1serial" kind="class" language="C++" prot="public" abstract="yes">
    <compoundname>embed::serial</compoundname>
    <basecompoundref refid="classembed_1_1driver" prot="public" virt="non-virtual">embed::driver&lt; serial_settings &gt;</basecompoundref>
    <includes refid="serial_8hpp" local="no">serial.hpp</includes>
      <sectiondef kind="public-func">
      <memberdef kind="function" id="classembed_1_1serial_1a2632150facd5b70f49dedea7108679d6" prot="public" static="no" const="no" explicit="no" inline="no" virt="pure-virtual">
        <type>void</type>
        <definition>virtual void embed::serial::write</definition>
        <argsstring>(std::span&lt; const std::byte &gt; p_data)=0</argsstring>
        <name>write</name>
        <param>
          <type>std::span&lt; const std::byte &gt;</type>
          <declname>p_data</declname>
        </param>
        <briefdescription>
<para>Write data on the transmitter line of the port. The exact implementation for this can be polling, interrupt driven or DMA driven. There is no guarantee on exactly how a write operation will operate, thus the <ref refid="classembed_1_1serial_1acaa9db822945c72a220f2ca7c4c03ab9" kindref="member">busy()</ref> function must polled called after this returns to determine if the write operation has finished. Attempting to call <ref refid="classembed_1_1serial_1a2632150facd5b70f49dedea7108679d6" kindref="member">write()</ref> when tranmission is busy is undefined behavior. </para>
        </briefdescription>
        <detaileddescription>
<para>Data frames are not compact when frame size is less than 8 bits. Meaning that, if you want to send three 5-bit frames, then you will need to use a span of at least 3 bytes to hold each value.</para>
<para>When writing data with frame size greater than 8 is in little endian order. Meaning that the first byte in the sequence is the lower byte and the next is the greater byte. If you wanted to send a 9-bit frame with value 0x14A, the first byte must be 0x4A and the next 0x01.</para>
<para><parameterlist kind="param"><parameteritem>
<parameternamelist>
<parametername>p_data</parametername>
</parameternamelist>
<parameterdescription>
<para>data to be transmitted over the serial port transmitter line </para>
</parameterdescription>
</parameteritem>
</parameterlist>
</para>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="/github/workspace/include/libembeddedhal/serial/serial.hpp" line="119" column="16"/>
      </memberdef>
      <memberdef kind="function" id="classembed_1_1serial_1acaa9db822945c72a220f2ca7c4c03ab9" prot="public" static="no" const="no" explicit="no" inline="no" virt="pure-virtual">
        <type>bool</type>
        <definition>virtual bool embed::serial::busy</definition>
        <argsstring>()=0</argsstring>
        <name>busy</name>
        <briefdescription>
<para>Determines if the write operation is currently on going. </para>
        </briefdescription>
        <detaileddescription>
<para><simplesect kind="return"><para>true serial transmitter is currently writing data to the port </para>
</simplesect>
<simplesect kind="return"><para>false serial transmitter is idle and available to write data </para>
</simplesect>
</para>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="/github/workspace/include/libembeddedhal/serial/serial.hpp" line="126" column="17"/>
      </memberdef>
      <memberdef kind="function" id="classembed_1_1serial_1a01006e49540c953a3bbc7bdfcb9d05c6" prot="public" static="no" const="no" explicit="no" inline="no" virt="pure-virtual">
        <type>size_t</type>
        <definition>virtual size_t embed::serial::bytes_available</definition>
        <argsstring>()=0</argsstring>
        <name>bytes_available</name>
        <briefdescription>
<para>The number of bytes that have been buffered. For frames less than 8-bits, each byte holds a frame. For frames above 8-bits the number of bytes returned indicates the number of bytes a buffer needs to be to return all of the data held in the buffer. </para>
        </briefdescription>
        <detaileddescription>
<para><simplesect kind="return"><para>size_t number of buffered by the serial driver and are available to be read by the <ref refid="classembed_1_1serial_1aff1745f3944aaaf9d467257db7a8282a" kindref="member">read()</ref> function. </para>
</simplesect>
</para>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="/github/workspace/include/libembeddedhal/serial/serial.hpp" line="136" column="19"/>
      </memberdef>
      <memberdef kind="function" id="classembed_1_1serial_1aff1745f3944aaaf9d467257db7a8282a" prot="public" static="no" const="no" explicit="no" inline="no" virt="pure-virtual">
        <type>std::span&lt; const std::byte &gt;</type>
        <definition>virtual std::span&lt;const std::byte&gt; embed::serial::read</definition>
        <argsstring>(std::span&lt; std::byte &gt; p_data)=0</argsstring>
        <name>read</name>
        <param>
          <type>std::span&lt; std::byte &gt;</type>
          <declname>p_data</declname>
        </param>
        <briefdescription>
<para>Read the bytes received over the ports receiver line and stored in the serial implementations buffer. The number of bytes read will subtract the number of bytes available until it reaches zero. </para>
        </briefdescription>
        <detaileddescription>
<para><parameterlist kind="param"><parameteritem>
<parameternamelist>
<parametername>p_data</parametername>
</parameternamelist>
<parameterdescription>
<para>Buffer to read bytes back from. If the length of this buffer is greater than the value returned by <ref refid="classembed_1_1serial_1a01006e49540c953a3bbc7bdfcb9d05c6" kindref="member">bytes_available()</ref> then buffer is filled up to the length returned by <ref refid="classembed_1_1serial_1a01006e49540c953a3bbc7bdfcb9d05c6" kindref="member">bytes_available()</ref>. The rest of the buffer is left untouched. </para>
</parameterdescription>
</parameteritem>
</parameterlist>
<simplesect kind="return"><para>std::span&lt;const std::byte&gt; provides a means to get the length of bytes read into the buffer p_data. The address will ALWAYS be the same as p_data and the length will be equal to the number of bytes read from the buffer. </para>
</simplesect>
</para>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="/github/workspace/include/libembeddedhal/serial/serial.hpp" line="151" column="21"/>
      </memberdef>
      <memberdef kind="function" id="classembed_1_1serial_1a241d49eb37b52bd1eadd830af0595319" prot="public" static="no" const="no" explicit="no" inline="no" virt="pure-virtual">
        <type>void</type>
        <definition>virtual void embed::serial::flush</definition>
        <argsstring>()=0</argsstring>
        <name>flush</name>
        <briefdescription>
<para>Set <ref refid="classembed_1_1serial_1a01006e49540c953a3bbc7bdfcb9d05c6" kindref="member">bytes_available()</ref> to zero and clear any received data stored in hardware registers. This operation must be faster than simply running <ref refid="classembed_1_1serial_1aff1745f3944aaaf9d467257db7a8282a" kindref="member">read()</ref> until <ref refid="classembed_1_1serial_1a01006e49540c953a3bbc7bdfcb9d05c6" kindref="member">bytes_available()</ref> is empty. </para>
        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="/github/workspace/include/libembeddedhal/serial/serial.hpp" line="158" column="16"/>
      </memberdef>
      </sectiondef>
    <briefdescription>
<para>Serial communication protocol hardware abstract interface. Use this interface for hardware that implements a serial protocol like UART, USART, RS232, RS485 and many others that use a similar communication protocol but may use different voltage schemes. </para>
    </briefdescription>
    <detaileddescription>
<para>Due to the asynchronous nature of serial communication protocols, all implementations of serial devices MUST buffer received bytes using DMA or interrupts. A thread should not be used as this generally greatly increases the ROM and RAM cost of using library.</para>
<para>All implementations MUST allow the user to supply their own buffer of arbitrary size, such that the amount of buffered data can be tailored to the needs of the application. </para>
    </detaileddescription>
    <inheritancegraph>
      <node id="1">
        <label>embed::serial</label>
        <link refid="classembed_1_1serial"/>
        <childnode refid="2" relation="public-inheritance">
        </childnode>
      </node>
      <node id="2">
        <label>embed::driver&lt; serial_settings &gt;</label>
        <link refid="classembed_1_1driver"/>
      </node>
    </inheritancegraph>
    <collaborationgraph>
      <node id="1">
        <label>embed::serial</label>
        <link refid="classembed_1_1serial"/>
        <childnode refid="2" relation="public-inheritance">
        </childnode>
      </node>
      <node id="2">
        <label>embed::driver&lt; serial_settings &gt;</label>
        <link refid="classembed_1_1driver"/>
      </node>
    </collaborationgraph>
    <location file="/github/workspace/include/libembeddedhal/serial/serial.hpp" line="97" column="1" bodyfile="/github/workspace/include/libembeddedhal/serial/serial.hpp" bodystart="98" bodyend="159"/>
    <listofallmembers>
      <member refid="classembed_1_1serial_1acaa9db822945c72a220f2ca7c4c03ab9" prot="public" virt="pure-virtual"><scope>embed::serial</scope><name>busy</name></member>
      <member refid="classembed_1_1serial_1a01006e49540c953a3bbc7bdfcb9d05c6" prot="public" virt="pure-virtual"><scope>embed::serial</scope><name>bytes_available</name></member>
      <member refid="classembed_1_1driver_1a1677362481d10c3b48544359daadf081" prot="protected" virt="pure-virtual"><scope>embed::serial</scope><name>driver_initialize</name></member>
      <member refid="classembed_1_1serial_1a241d49eb37b52bd1eadd830af0595319" prot="public" virt="pure-virtual"><scope>embed::serial</scope><name>flush</name></member>
      <member refid="classembed_1_1driver_1a947a3487fa3acd0879e83872d9c97b01" prot="public" virt="non-virtual"><scope>embed::serial</scope><name>initialize</name></member>
      <member refid="classembed_1_1driver_1a7e13fe8999142475da8c5b84927f03aa" prot="public" virt="non-virtual"><scope>embed::serial</scope><name>initialized_settings</name></member>
      <member refid="classembed_1_1driver_1a346f472e8c212d09c8f45aebd0089d7b" prot="public" virt="non-virtual"><scope>embed::serial</scope><name>is_initialized</name></member>
      <member refid="classembed_1_1driver_1ab8b2029f33d55b9ffffd6e88d846cd7b" prot="protected" virt="non-virtual"><scope>embed::serial</scope><name>m_initialized</name></member>
      <member refid="classembed_1_1driver_1aac7d23e384bc27a26b77c8fd681483ef" prot="protected" virt="non-virtual"><scope>embed::serial</scope><name>m_initialized_settings</name></member>
      <member refid="classembed_1_1driver_1afb925433a5897293609af5fae29e3dc3" prot="protected" virt="non-virtual"><scope>embed::serial</scope><name>m_settings</name></member>
      <member refid="classembed_1_1serial_1aff1745f3944aaaf9d467257db7a8282a" prot="public" virt="pure-virtual"><scope>embed::serial</scope><name>read</name></member>
      <member refid="classembed_1_1driver_1a54440bf23c0c34102f563da1193d99ae" prot="public" virt="non-virtual"><scope>embed::serial</scope><name>reset</name></member>
      <member refid="classembed_1_1driver_1ae6eb991ebb2321bb3565c2a03a613219" prot="public" virt="non-virtual"><scope>embed::serial</scope><name>settings</name></member>
      <member refid="classembed_1_1serial_1a2632150facd5b70f49dedea7108679d6" prot="public" virt="pure-virtual"><scope>embed::serial</scope><name>write</name></member>
    </listofallmembers>
  </compounddef>
</doxygen>
