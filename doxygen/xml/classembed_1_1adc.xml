<?xml version='1.0' encoding='UTF-8' standalone='no'?>
<doxygen xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xsi:noNamespaceSchemaLocation="compound.xsd" version="1.9.1" xml:lang="en-US">
  <compounddef id="classembed_1_1adc" kind="class" language="C++" prot="public" abstract="yes">
    <compoundname>embed::adc</compoundname>
    <basecompoundref refid="classembed_1_1driver" prot="public" virt="non-virtual">embed::driver&lt;&gt;</basecompoundref>
    <includes refid="adc_8hpp" local="no">adc.hpp</includes>
      <sectiondef kind="private-func">
      <memberdef kind="function" id="classembed_1_1adc_1a234368fe6b85240d0ed257b0d7dcfc16" prot="private" static="no" const="no" explicit="no" inline="no" virt="pure-virtual">
        <type><ref refid="classembed_1_1full__scale" kindref="compound">full_scale</ref>&lt; uint32_t &gt;</type>
        <definition>virtual full_scale&lt;uint32_t&gt; embed::adc::read</definition>
        <argsstring>()=0</argsstring>
        <name>read</name>
        <briefdescription>
<para>Read a sample from the analog to digital converter. This function makes no assumptions about how the conversation is made via the ADC. Conversions could be performed at each call of this function. Conversions can be ongoing by hardware and this function returns the latest sample or the first sample from a queue. The conversation can also occur over a communication protocol like SPI or I2C which could effect the time it takes for this function to return. It is the responsibility of the application developer to understand how a particular ADC will effect their application. </para>
        </briefdescription>
        <detaileddescription>
<para><simplesect kind="return"><para>full_scale&lt;uint32_t&gt; This value acts a precentage scale from where 0 represents the lowest possible voltage reading the ADC can return and UINT32T_MAX representing the maximum. It is up to the application developer to know what the low and high voltage ranges are for the ADC and scale this value to the correct voltage as needed. As an example, if the low end for the ADC is 0V and the high is 3.3V and the input voltage is 1.65V (or half 3.3V), then the full scale value will return 2147483647 or (2^32 - 1) / 2. </para>
</simplesect>
</para>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="/github/workspace/include/libembeddedhal/adc/adc.hpp" line="36" column="22"/>
      </memberdef>
      </sectiondef>
    <briefdescription>
<para>Analog to Digital Converter (ADC) hardware abstraction interface. Use this interface for devices and peripherals that can convert analog voltage signals into a digital number. </para>
    </briefdescription>
    <detaileddescription>
    </detaileddescription>
    <inheritancegraph>
      <node id="2">
        <label>embed::driver&lt; settings_t &gt;</label>
        <link refid="classembed_1_1driver"/>
      </node>
      <node id="1">
        <label>embed::adc</label>
        <link refid="classembed_1_1adc"/>
        <childnode refid="2" relation="public-inheritance">
        </childnode>
      </node>
    </inheritancegraph>
    <collaborationgraph>
      <node id="2">
        <label>embed::driver&lt; settings_t &gt;</label>
        <link refid="classembed_1_1driver"/>
        <childnode refid="3" relation="usage">
          <edgelabel>m_initialized_settings</edgelabel>
          <edgelabel>m_settings</edgelabel>
        </childnode>
      </node>
      <node id="3">
        <label>embed::no_settings</label>
        <link refid="structembed_1_1no__settings"/>
      </node>
      <node id="1">
        <label>embed::adc</label>
        <link refid="classembed_1_1adc"/>
        <childnode refid="2" relation="public-inheritance">
        </childnode>
      </node>
    </collaborationgraph>
    <location file="/github/workspace/include/libembeddedhal/adc/adc.hpp" line="15" column="1" bodyfile="/github/workspace/include/libembeddedhal/adc/adc.hpp" bodystart="16" bodyend="37"/>
    <listofallmembers>
      <member refid="classembed_1_1driver_1a1677362481d10c3b48544359daadf081" prot="protected" virt="pure-virtual"><scope>embed::adc</scope><name>driver_initialize</name></member>
      <member refid="classembed_1_1driver_1a947a3487fa3acd0879e83872d9c97b01" prot="public" virt="non-virtual"><scope>embed::adc</scope><name>initialize</name></member>
      <member refid="classembed_1_1driver_1a7e13fe8999142475da8c5b84927f03aa" prot="public" virt="non-virtual"><scope>embed::adc</scope><name>initialized_settings</name></member>
      <member refid="classembed_1_1driver_1a346f472e8c212d09c8f45aebd0089d7b" prot="public" virt="non-virtual"><scope>embed::adc</scope><name>is_initialized</name></member>
      <member refid="classembed_1_1driver_1ab8b2029f33d55b9ffffd6e88d846cd7b" prot="protected" virt="non-virtual"><scope>embed::adc</scope><name>m_initialized</name></member>
      <member refid="classembed_1_1driver_1aac7d23e384bc27a26b77c8fd681483ef" prot="protected" virt="non-virtual"><scope>embed::adc</scope><name>m_initialized_settings</name></member>
      <member refid="classembed_1_1driver_1afb925433a5897293609af5fae29e3dc3" prot="protected" virt="non-virtual"><scope>embed::adc</scope><name>m_settings</name></member>
      <member refid="classembed_1_1adc_1a234368fe6b85240d0ed257b0d7dcfc16" prot="private" virt="pure-virtual"><scope>embed::adc</scope><name>read</name></member>
      <member refid="classembed_1_1driver_1a54440bf23c0c34102f563da1193d99ae" prot="public" virt="non-virtual"><scope>embed::adc</scope><name>reset</name></member>
      <member refid="classembed_1_1driver_1ae6eb991ebb2321bb3565c2a03a613219" prot="public" virt="non-virtual"><scope>embed::adc</scope><name>settings</name></member>
    </listofallmembers>
  </compounddef>
</doxygen>
