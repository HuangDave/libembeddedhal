<?xml version='1.0' encoding='UTF-8' standalone='no'?>
<doxygen xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xsi:noNamespaceSchemaLocation="compound.xsd" version="1.9.1" xml:lang="en-US">
  <compounddef id="classembed_1_1can__network_1_1node__t" kind="class" language="C++" prot="public">
    <compoundname>embed::can_network::node_t</compoundname>
    <includes refid="can__network_8hpp" local="no">can_network.hpp</includes>
      <sectiondef kind="private-attrib">
      <memberdef kind="variable" id="classembed_1_1can__network_1_1node__t_1a1f31f566fe3ab4f7b41546128c55e3f1" prot="private" static="no" mutable="no">
        <type>friend</type>
        <definition>friend embed::can_network::node_t::can_network</definition>
        <argsstring></argsstring>
        <name>can_network</name>
        <briefdescription>
        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="/github/workspace/include/libembeddedhal/can/can_network.hpp" line="78" column="12" bodyfile="/github/workspace/include/libembeddedhal/can/can_network.hpp" bodystart="75" bodyend="-1"/>
      </memberdef>
      <memberdef kind="variable" id="classembed_1_1can__network_1_1node__t_1a6da8f9ba51409dbea82d145cad1cd9bd" prot="private" static="no" mutable="no">
        <type><ref refid="structembed_1_1can_1_1message__t" kindref="compound">can::message_t</ref></type>
        <definition>can::message_t embed::can_network::node_t::data</definition>
        <argsstring></argsstring>
        <name>data</name>
        <initializer>= {}</initializer>
        <briefdescription>
<para>Holds the latest received can message;. </para>
        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="/github/workspace/include/libembeddedhal/can/can_network.hpp" line="104" column="20" bodyfile="/github/workspace/include/libembeddedhal/can/can_network.hpp" bodystart="104" bodyend="-1"/>
      </memberdef>
      <memberdef kind="variable" id="classembed_1_1can__network_1_1node__t_1a81604de320e6df7f7bf195769c28d0c1" prot="private" static="no" mutable="no">
        <type>std::atomic&lt; int &gt;</type>
        <definition>std::atomic&lt;int&gt; embed::can_network::node_t::access_counter</definition>
        <argsstring></argsstring>
        <name>access_counter</name>
        <initializer>= 0</initializer>
        <briefdescription>
<para>Used to indicate when the data field is being accessed. </para>
        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="/github/workspace/include/libembeddedhal/can/can_network.hpp" line="107" column="17" bodyfile="/github/workspace/include/libembeddedhal/can/can_network.hpp" bodystart="107" bodyend="-1"/>
      </memberdef>
      </sectiondef>
      <sectiondef kind="public-func">
      <memberdef kind="function" id="classembed_1_1can__network_1_1node__t_1a8b2c7f9f34d8fbe65526b245c21bb5c9" prot="public" static="no" const="no" explicit="no" inline="yes" noexcept="yes" virt="non-virtual">
        <type></type>
        <definition>embed::can_network::node_t::node_t</definition>
        <argsstring>() noexcept</argsstring>
        <name>node_t</name>
        <briefdescription>
<para>Default constructor. </para>
        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="/github/workspace/include/libembeddedhal/can/can_network.hpp" line="34" column="5" bodyfile="/github/workspace/include/libembeddedhal/can/can_network.hpp" bodystart="34" bodyend="34"/>
      </memberdef>
      <memberdef kind="function" id="classembed_1_1can__network_1_1node__t_1ad1fe9561adf224ed08073cbedd46f233" prot="public" static="no" const="no" explicit="no" inline="yes" noexcept="yes" virt="non-virtual">
        <type><ref refid="classembed_1_1can__network_1_1node__t" kindref="compound">node_t</ref> &amp;</type>
        <definition>node_t&amp; embed::can_network::node_t::operator=</definition>
        <argsstring>(const node_t &amp;node) noexcept</argsstring>
        <name>operator=</name>
        <param>
          <type>const <ref refid="classembed_1_1can__network_1_1node__t" kindref="compound">node_t</ref> &amp;</type>
          <declname>node</declname>
        </param>
        <briefdescription>
<para>Node assignment operator. </para>
        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="/github/workspace/include/libembeddedhal/can/can_network.hpp" line="37" column="12" bodyfile="/github/workspace/include/libembeddedhal/can/can_network.hpp" bodystart="37" bodyend="42"/>
      </memberdef>
      <memberdef kind="function" id="classembed_1_1can__network_1_1node__t_1ab2ca030b6309e21d47f2295a3e15f697" prot="public" static="no" const="no" explicit="no" inline="yes" noexcept="yes" virt="non-virtual">
        <type></type>
        <definition>embed::can_network::node_t::node_t</definition>
        <argsstring>(const node_t &amp;node) noexcept</argsstring>
        <name>node_t</name>
        <param>
          <type>const <ref refid="classembed_1_1can__network_1_1node__t" kindref="compound">node_t</ref> &amp;</type>
          <declname>node</declname>
        </param>
        <briefdescription>
<para>Copy constructor. </para>
        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="/github/workspace/include/libembeddedhal/can/can_network.hpp" line="45" column="5" bodyfile="/github/workspace/include/libembeddedhal/can/can_network.hpp" bodystart="45" bodyend="45"/>
      </memberdef>
      <memberdef kind="function" id="classembed_1_1can__network_1_1node__t_1ad412ab57392b6b8a722d921b8c5980b9" prot="public" static="no" const="no" explicit="no" inline="yes" virt="non-virtual">
        <type><ref refid="structembed_1_1can_1_1message__t" kindref="compound">can::message_t</ref></type>
        <definition>can::message_t embed::can_network::node_t::secure_get</definition>
        <argsstring>()</argsstring>
        <name>secure_get</name>
        <briefdescription>
        </briefdescription>
        <detaileddescription>
<para>Return a CAN message, but only do so if the CAN message of this node is not currently be modified by another thread that is using the update() method. </para>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="/github/workspace/include/libembeddedhal/can/can_network.hpp" line="50" column="20" bodyfile="/github/workspace/include/libembeddedhal/can/can_network.hpp" bodystart="50" bodyend="75"/>
      </memberdef>
      </sectiondef>
      <sectiondef kind="private-func">
      <memberdef kind="function" id="classembed_1_1can__network_1_1node__t_1add4d8732fb274d1b947ed2fe36c7b01c" prot="private" static="no" const="no" explicit="no" inline="yes" virt="non-virtual">
        <type>void</type>
        <definition>void embed::can_network::node_t::update</definition>
        <argsstring>(const can::message_t &amp;new_data)</argsstring>
        <name>update</name>
        <param>
          <type>const <ref refid="structembed_1_1can_1_1message__t" kindref="compound">can::message_t</ref> &amp;</type>
          <declname>new_data</declname>
        </param>
        <briefdescription>
        </briefdescription>
        <detaileddescription>
<para>updates the can message in a lock-free way. Can only be accessed by the <ref refid="classembed_1_1can__network" kindref="compound">can_network</ref> class.</para>
<para><parameterlist kind="param"><parameteritem>
<parameternamelist>
<parametername>new_data</parametername>
</parameternamelist>
<parameterdescription>
<para>- New CAN message to store </para>
</parameterdescription>
</parameteritem>
</parameterlist>
</para>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="/github/workspace/include/libembeddedhal/can/can_network.hpp" line="84" column="10" bodyfile="/github/workspace/include/libembeddedhal/can/can_network.hpp" bodystart="84" bodyend="101"/>
      </memberdef>
      </sectiondef>
    <briefdescription>
    </briefdescription>
    <detaileddescription>
<para>The node stored in the <ref refid="classembed_1_1can__network" kindref="compound">can_network</ref> map. Holds the latest CAN message and contains methods for updating and retreiving can messages in a thread-safe manner that does not invoke OS locks.</para>
<para>Updating the CAN message data is completely lock free. Retrieving data is NOT lock free, but instead uses atomics to poll for when the update() function has completed in some other thread. This asymmetry in locking is to reduce latency for write case rather than than read case. Storing a CAN message is typically done via an interrupt service routine or a thread that MUST NOT block in anyway or the system can lock up. Where as reading data typically is done by a userspace thread which can typically wait a few cycles to get its data. </para>
    </detaileddescription>
    <location file="/github/workspace/include/libembeddedhal/can/can_network.hpp" line="30" column="3" bodyfile="/github/workspace/include/libembeddedhal/can/can_network.hpp" bodystart="31" bodyend="108"/>
    <listofallmembers>
      <member refid="classembed_1_1can__network_1_1node__t_1a81604de320e6df7f7bf195769c28d0c1" prot="private" virt="non-virtual"><scope>embed::can_network::node_t</scope><name>access_counter</name></member>
      <member refid="classembed_1_1can__network_1_1node__t_1a1f31f566fe3ab4f7b41546128c55e3f1" prot="private" virt="non-virtual"><scope>embed::can_network::node_t</scope><name>can_network</name></member>
      <member refid="classembed_1_1can__network_1_1node__t_1a6da8f9ba51409dbea82d145cad1cd9bd" prot="private" virt="non-virtual"><scope>embed::can_network::node_t</scope><name>data</name></member>
      <member refid="classembed_1_1can__network_1_1node__t_1a8b2c7f9f34d8fbe65526b245c21bb5c9" prot="public" virt="non-virtual"><scope>embed::can_network::node_t</scope><name>node_t</name></member>
      <member refid="classembed_1_1can__network_1_1node__t_1ab2ca030b6309e21d47f2295a3e15f697" prot="public" virt="non-virtual"><scope>embed::can_network::node_t</scope><name>node_t</name></member>
      <member refid="classembed_1_1can__network_1_1node__t_1ad1fe9561adf224ed08073cbedd46f233" prot="public" virt="non-virtual"><scope>embed::can_network::node_t</scope><name>operator=</name></member>
      <member refid="classembed_1_1can__network_1_1node__t_1ad412ab57392b6b8a722d921b8c5980b9" prot="public" virt="non-virtual"><scope>embed::can_network::node_t</scope><name>secure_get</name></member>
      <member refid="classembed_1_1can__network_1_1node__t_1add4d8732fb274d1b947ed2fe36c7b01c" prot="private" virt="non-virtual"><scope>embed::can_network::node_t</scope><name>update</name></member>
    </listofallmembers>
  </compounddef>
</doxygen>
