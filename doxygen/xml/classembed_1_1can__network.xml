<?xml version='1.0' encoding='UTF-8' standalone='no'?>
<doxygen xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xsi:noNamespaceSchemaLocation="compound.xsd" version="1.9.1" xml:lang="en-US">
  <compounddef id="classembed_1_1can__network" kind="class" language="C++" prot="public">
    <compoundname>embed::can_network</compoundname>
    <basecompoundref refid="classembed_1_1driver" prot="public" virt="non-virtual">embed::driver&lt;&gt;</basecompoundref>
    <includes refid="can__network_8hpp" local="no">can_network.hpp</includes>
    <innerclass refid="classembed_1_1can__network_1_1node__t" prot="public">embed::can_network::node_t</innerclass>
      <sectiondef kind="private-attrib">
      <memberdef kind="variable" id="classembed_1_1can__network_1a7e0dae220f46a5406f548a961478ef34" prot="private" static="no" mutable="no">
        <type><ref refid="classembed_1_1can" kindref="compound">can</ref> &amp;</type>
        <definition>can&amp; embed::can_network::m_can</definition>
        <argsstring></argsstring>
        <name>m_can</name>
        <briefdescription>
        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="/github/workspace/include/libembeddedhal/can/can_network.hpp" line="203" column="7" bodyfile="/github/workspace/include/libembeddedhal/can/can_network.hpp" bodystart="203" bodyend="-1"/>
      </memberdef>
      <memberdef kind="variable" id="classembed_1_1can__network_1ad2bd818ef73c6e499e88898e172d0b17" prot="private" static="no" mutable="no">
        <type>std::pmr::unordered_map&lt; uint32_t, <ref refid="classembed_1_1can__network_1_1node__t" kindref="compound">node_t</ref> &gt;</type>
        <definition>std::pmr::unordered_map&lt;uint32_t, node_t&gt; embed::can_network::m_messages</definition>
        <argsstring></argsstring>
        <name>m_messages</name>
        <briefdescription>
        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="/github/workspace/include/libembeddedhal/can/can_network.hpp" line="204" column="27" bodyfile="/github/workspace/include/libembeddedhal/can/can_network.hpp" bodystart="204" bodyend="-1"/>
      </memberdef>
      </sectiondef>
      <sectiondef kind="public-func">
      <memberdef kind="function" id="classembed_1_1can__network_1ab753d9f66866c86c81acb75558d6f105" prot="public" static="no" const="no" explicit="no" inline="yes" noexcept="yes" virt="non-virtual">
        <type></type>
        <definition>embed::can_network::can_network</definition>
        <argsstring>(can &amp;p_can, std::pmr::memory_resource &amp;p_memory_resource) noexcept</argsstring>
        <name>can_network</name>
        <param>
          <type><ref refid="classembed_1_1can" kindref="compound">can</ref> &amp;</type>
          <declname>p_can</declname>
        </param>
        <param>
          <type>std::pmr::memory_resource &amp;</type>
          <declname>p_memory_resource</declname>
        </param>
        <briefdescription>
        </briefdescription>
        <detaileddescription>
<para><parameterlist kind="param"><parameteritem>
<parameternamelist>
<parametername>can</parametername>
</parameternamelist>
<parameterdescription>
<para>- CAN peripheral to manage the network of. </para>
</parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername>memory_resource</parametername>
</parameternamelist>
<parameterdescription>
<para>- pointer to a memory resource. </para>
</parameterdescription>
</parameteritem>
</parameterlist>
</para>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="/github/workspace/include/libembeddedhal/can/can_network.hpp" line="112" column="3" bodyfile="/github/workspace/include/libembeddedhal/can/can_network.hpp" bodystart="112" bodyend="115"/>
      </memberdef>
      <memberdef kind="function" id="classembed_1_1can__network_1a252f3734fb6b491f71285e998f73ddd9" prot="public" static="no" const="no" explicit="no" inline="yes" virt="virtual">
        <type>bool</type>
        <definition>bool embed::can_network::driver_initialize</definition>
        <argsstring>() override</argsstring>
        <name>driver_initialize</name>
        <reimplements refid="classembed_1_1driver_1a1677362481d10c3b48544359daadf081">driver_initialize</reimplements>
        <briefdescription>
        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="/github/workspace/include/libembeddedhal/can/can_network.hpp" line="117" column="8" bodyfile="/github/workspace/include/libembeddedhal/can/can_network.hpp" bodystart="117" bodyend="124"/>
      </memberdef>
      <memberdef kind="function" id="classembed_1_1can__network_1abbc1679f4d5b8e0359badb6e746bad9c" prot="public" static="no" const="no" explicit="no" inline="yes" virt="non-virtual">
        <type><ref refid="classembed_1_1can__network_1_1node__t" kindref="compound">node_t</ref> *</type>
        <definition>node_t* embed::can_network::register_message_id</definition>
        <argsstring>(can::id_t id)</argsstring>
        <name>register_message_id</name>
        <param>
          <type><ref refid="classembed_1_1can_1a526ae12b76dffd3dda0891247da12b55" kindref="member">can::id_t</ref></type>
          <declname>id</declname>
        </param>
        <briefdescription>
        </briefdescription>
        <detaileddescription>
<para>In order for a CAN message with an associated ID to be stored in the <ref refid="classembed_1_1can__network" kindref="compound">can_network</ref>, it must be declared using this method. For example if you expect to get the following IDs 0x140, 0x7AA, and 0x561 from the CAN bus, then this method must be called as such:</para>
<para><programlisting><codeline><highlight class="normal">node_t<sp/>*<sp/>motor_node<sp/><sp/><sp/><sp/><sp/><sp/><sp/>=<sp/>can_network.register_message_id(0x140);</highlight></codeline>
<codeline><highlight class="normal">node_t<sp/>*<sp/>encoder_node<sp/><sp/><sp/><sp/><sp/>=<sp/>can_network.register_message_id(0x561);</highlight></codeline>
<codeline><highlight class="normal">node_t<sp/>*<sp/>temperature_node<sp/>=<sp/>can_network.register_message_id(0x7AA);</highlight></codeline>
</programlisting></para>
<para><parameterlist kind="param"><parameteritem>
<parameternamelist>
<parametername>id</parametername>
</parameternamelist>
<parameterdescription>
<para>- Associated ID of messages to be stored. </para>
</parameterdescription>
</parameteritem>
</parameterlist>
<parameterlist kind="exception"><parameteritem>
<parameternamelist>
<parametername>std::bad_alloc</parametername>
</parameternamelist>
<parameterdescription>
<para>if this static storage allocated for this object is not enough to hold </para>
</parameterdescription>
</parameteritem>
</parameterlist>
<simplesect kind="return"><para>node_t* - reference to the CANBUS network <ref refid="classembed_1_1can__network_1_1node__t" kindref="compound">node_t</ref> which can be used at anytime to retreive the latest received message from the CANBUS that is associated with the set ID. </para>
</simplesect>
</para>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="/github/workspace/include/libembeddedhal/can/can_network.hpp" line="143" column="11" bodyfile="/github/workspace/include/libembeddedhal/can/can_network.hpp" bodystart="143" bodyend="156"/>
      </memberdef>
      <memberdef kind="function" id="classembed_1_1can__network_1af65e894f1ad841bbec996020ab83a9f9" prot="public" static="no" const="no" explicit="no" inline="yes" virt="non-virtual">
        <type>void</type>
        <definition>void embed::can_network::manually_call_receive_handler</definition>
        <argsstring>()</argsstring>
        <name>manually_call_receive_handler</name>
        <briefdescription>
        </briefdescription>
        <detaileddescription>
<para>Manually call the receive handler. This is useful for unit testing and for CANBUS peripherals that do NOT have a receive message interrupt routine. In the later case, a software (potentially a thread) can perform the receive call manually to extract messages from the CAN peripheral FIFO. This method cannot guarantee that data is not lost if the FIFO fills up. </para>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="/github/workspace/include/libembeddedhal/can/can_network.hpp" line="163" column="8" bodyfile="/github/workspace/include/libembeddedhal/can/can_network.hpp" bodystart="163" bodyend="163"/>
      </memberdef>
      <memberdef kind="function" id="classembed_1_1can__network_1a8a88151b0137da5fe3e09e99992568d0" prot="public" static="no" const="no" explicit="no" inline="yes" virt="non-virtual">
        <type><ref refid="classembed_1_1can" kindref="compound">can</ref> &amp;</type>
        <definition>can&amp; embed::can_network::bus</definition>
        <argsstring>()</argsstring>
        <name>bus</name>
        <briefdescription>
        </briefdescription>
        <detaileddescription>
<para>Return the CAN peripheral object which can be used to initialize, configure, and enable the peripheral as well as transmit messages. Access to this object, if a <ref refid="classembed_1_1can__network" kindref="compound">can_network</ref> </para>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="/github/workspace/include/libembeddedhal/can/can_network.hpp" line="168" column="7" bodyfile="/github/workspace/include/libembeddedhal/can/can_network.hpp" bodystart="168" bodyend="168"/>
      </memberdef>
      <memberdef kind="function" id="classembed_1_1can__network_1aaab256f31f0435d1277292d54a0aaa44" prot="public" static="no" const="no" explicit="no" inline="yes" virt="non-virtual">
        <type>const auto &amp;</type>
        <definition>const auto&amp; embed::can_network::GetInternalMap</definition>
        <argsstring>()</argsstring>
        <name>GetInternalMap</name>
        <briefdescription>
        </briefdescription>
        <detaileddescription>
<para>Meant for testing purposes or when direct inspection of the map is useful in userspace. Should not be used in by libraries. </para>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="/github/workspace/include/libembeddedhal/can/can_network.hpp" line="172" column="14" bodyfile="/github/workspace/include/libembeddedhal/can/can_network.hpp" bodystart="172" bodyend="172"/>
      </memberdef>
      </sectiondef>
      <sectiondef kind="private-func">
      <memberdef kind="function" id="classembed_1_1can__network_1a3ae7a5c67e2a3f929a955753496f7e0d" prot="private" static="no" const="no" explicit="no" inline="yes" virt="non-virtual">
        <type>void</type>
        <definition>void embed::can_network::receive_handler</definition>
        <argsstring>(can &amp;p_can)</argsstring>
        <name>receive_handler</name>
        <param>
          <type><ref refid="classembed_1_1can" kindref="compound">can</ref> &amp;</type>
          <declname>p_can</declname>
        </param>
        <briefdescription>
        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="/github/workspace/include/libembeddedhal/can/can_network.hpp" line="175" column="8" bodyfile="/github/workspace/include/libembeddedhal/can/can_network.hpp" bodystart="175" bodyend="201"/>
      </memberdef>
      </sectiondef>
    <briefdescription>
<para><ref refid="classembed_1_1can__network" kindref="compound">can_network</ref> is a canbus message receiver handler and </para>
    </briefdescription>
    <detaileddescription>
    </detaileddescription>
    <inheritancegraph>
      <node id="2">
        <label>embed::driver&lt; settings_t &gt;</label>
        <link refid="classembed_1_1driver"/>
      </node>
      <node id="1">
        <label>embed::can_network</label>
        <link refid="classembed_1_1can__network"/>
        <childnode refid="2" relation="public-inheritance">
        </childnode>
      </node>
    </inheritancegraph>
    <collaborationgraph>
      <node id="2">
        <label>embed::driver&lt; settings_t &gt;</label>
        <link refid="classembed_1_1driver"/>
        <childnode refid="3" relation="usage">
          <edgelabel>m_initialized_settings</edgelabel>
          <edgelabel>m_settings</edgelabel>
        </childnode>
      </node>
      <node id="1">
        <label>embed::can_network</label>
        <link refid="classembed_1_1can__network"/>
        <childnode refid="2" relation="public-inheritance">
        </childnode>
      </node>
      <node id="3">
        <label>embed::no_settings</label>
        <link refid="structembed_1_1no__settings"/>
      </node>
    </collaborationgraph>
    <location file="/github/workspace/include/libembeddedhal/can/can_network.hpp" line="15" column="1" bodyfile="/github/workspace/include/libembeddedhal/can/can_network.hpp" bodystart="16" bodyend="205"/>
    <listofallmembers>
      <member refid="classembed_1_1can__network_1a8a88151b0137da5fe3e09e99992568d0" prot="public" virt="non-virtual"><scope>embed::can_network</scope><name>bus</name></member>
      <member refid="classembed_1_1can__network_1ab753d9f66866c86c81acb75558d6f105" prot="public" virt="non-virtual"><scope>embed::can_network</scope><name>can_network</name></member>
      <member refid="classembed_1_1can__network_1a252f3734fb6b491f71285e998f73ddd9" prot="public" virt="virtual"><scope>embed::can_network</scope><name>driver_initialize</name></member>
      <member refid="classembed_1_1can__network_1aaab256f31f0435d1277292d54a0aaa44" prot="public" virt="non-virtual"><scope>embed::can_network</scope><name>GetInternalMap</name></member>
      <member refid="classembed_1_1driver_1a947a3487fa3acd0879e83872d9c97b01" prot="public" virt="non-virtual"><scope>embed::can_network</scope><name>initialize</name></member>
      <member refid="classembed_1_1driver_1a7e13fe8999142475da8c5b84927f03aa" prot="public" virt="non-virtual"><scope>embed::can_network</scope><name>initialized_settings</name></member>
      <member refid="classembed_1_1driver_1a346f472e8c212d09c8f45aebd0089d7b" prot="public" virt="non-virtual"><scope>embed::can_network</scope><name>is_initialized</name></member>
      <member refid="classembed_1_1can__network_1a7e0dae220f46a5406f548a961478ef34" prot="private" virt="non-virtual"><scope>embed::can_network</scope><name>m_can</name></member>
      <member refid="classembed_1_1driver_1ab8b2029f33d55b9ffffd6e88d846cd7b" prot="protected" virt="non-virtual"><scope>embed::can_network</scope><name>m_initialized</name></member>
      <member refid="classembed_1_1driver_1aac7d23e384bc27a26b77c8fd681483ef" prot="protected" virt="non-virtual"><scope>embed::can_network</scope><name>m_initialized_settings</name></member>
      <member refid="classembed_1_1can__network_1ad2bd818ef73c6e499e88898e172d0b17" prot="private" virt="non-virtual"><scope>embed::can_network</scope><name>m_messages</name></member>
      <member refid="classembed_1_1driver_1afb925433a5897293609af5fae29e3dc3" prot="protected" virt="non-virtual"><scope>embed::can_network</scope><name>m_settings</name></member>
      <member refid="classembed_1_1can__network_1af65e894f1ad841bbec996020ab83a9f9" prot="public" virt="non-virtual"><scope>embed::can_network</scope><name>manually_call_receive_handler</name></member>
      <member refid="classembed_1_1can__network_1a3ae7a5c67e2a3f929a955753496f7e0d" prot="private" virt="non-virtual"><scope>embed::can_network</scope><name>receive_handler</name></member>
      <member refid="classembed_1_1can__network_1abbc1679f4d5b8e0359badb6e746bad9c" prot="public" virt="non-virtual"><scope>embed::can_network</scope><name>register_message_id</name></member>
      <member refid="classembed_1_1driver_1a54440bf23c0c34102f563da1193d99ae" prot="public" virt="non-virtual"><scope>embed::can_network</scope><name>reset</name></member>
      <member refid="classembed_1_1driver_1ae6eb991ebb2321bb3565c2a03a613219" prot="public" virt="non-virtual"><scope>embed::can_network</scope><name>settings</name></member>
    </listofallmembers>
  </compounddef>
</doxygen>
