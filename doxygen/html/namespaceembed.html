<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "https://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.9.1"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>libembeddedhal API: embed Namespace Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectalign" style="padding-left: 0.5em;">
   <div id="projectname">libembeddedhal API
   </div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.9.1 -->
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
var searchBox = new SearchBox("searchBox", "search",false,'Search','.html');
/* @license-end */
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
$(function() {
  initMenu('',true,false,'search.php','Search');
  $(document).ready(function() { init_search(); });
});
/* @license-end */</script>
<div id="main-nav"></div>
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

</div><!-- top -->
<div class="header">
  <div class="summary">
<a href="#namespaces">Namespaces</a> &#124;
<a href="#nested-classes">Classes</a> &#124;
<a href="#enum-members">Enumerations</a> &#124;
<a href="#func-members">Functions</a> &#124;
<a href="#var-members">Variables</a>  </div>
  <div class="headertitle">
<div class="title">embed Namespace Reference</div>  </div>
</div><!--header-->
<div class="contents">
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="namespaces"></a>
Namespaces</h2></td></tr>
<tr class="memitem:namespaceembed_1_1this__thread"><td class="memItemLeft" align="right" valign="top"> &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceembed_1_1this__thread.html">this_thread</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="nested-classes"></a>
Classes</h2></td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classembed_1_1adc.html">adc</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Analog to Digital Converter (ADC) hardware abstraction interface. Use this interface for devices and peripherals that can convert analog voltage signals into a digital number.  <a href="classembed_1_1adc.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structembed_1_1can__settings.html">can_settings</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classembed_1_1can.html">can</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classembed_1_1can__network.html">can_network</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight"><a class="el" href="classembed_1_1can__network.html" title="can_network is a canbus message receiver handler and">can_network</a> is a canbus message receiver handler and  <a href="classembed_1_1can__network.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classembed_1_1counter.html">counter</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Counter hardware abstraction interface. Use this interface for devices and peripherals that have counting capabilities. Such devices can count up or down. Useful for keeping time. Expect counters to overflow when they reach the end of counting register's limits.  <a href="classembed_1_1counter.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classembed_1_1dac.html">dac</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Digital to Analog Converter (DAC) hardware abstraction interface. Use this interface for devices and peripherals that can create arbitrary analog voltages between a defined LOW and HIGH voltage.  <a href="classembed_1_1dac.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structembed_1_1invalid__option__t.html">invalid_option_t</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Used for defining static_asserts that should always fail, but only if the static_assert line is hit via <code>if constexpr</code> control block. Prefer to NOT use this directly but to use <code>invalid_option</code> instead.  <a href="structembed_1_1invalid__option__t.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structembed_1_1no__settings.html">no_settings</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">An empty settings structure used to indicate that a driver or interface does not have generic settings.  <a href="structembed_1_1no__settings.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classembed_1_1driver.html">driver</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">The basis class for all peripheral, device and system drivers in libembeddedhal.  <a href="classembed_1_1driver.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classembed_1_1bit__limits.html">bit_limits</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structembed_1_1bit__depth.html">bit_depth</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classembed_1_1full__scale.html">full_scale</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structembed_1_1input__pin__settings.html">input_pin_settings</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Generic settings for input pins.  <a href="structembed_1_1input__pin__settings.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structembed_1_1output__pin__settings.html">output_pin_settings</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Generic settings for output pins.  <a href="structembed_1_1output__pin__settings.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structembed_1_1interrupt__pin__settings.html">interrupt_pin_settings</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Generic settings for interrupt pins.  <a href="structembed_1_1interrupt__pin__settings.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classembed_1_1input__pin.html">input_pin</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Digital input pin hardware abstraction. Use this to read a pin and determine if the voltage on it is HIGH or LOW.  <a href="classembed_1_1input__pin.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classembed_1_1output__pin.html">output_pin</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Digital output pin hardware abstraction. Use this to drive a pin HIGH or LOW in order to send a control signal or turn off or on an LED.  <a href="classembed_1_1output__pin.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classembed_1_1interrupt__pin.html">interrupt_pin</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Digital interrupt pin hardware abstraction. Use this to trigger an interrupt service routine (ISR) when a pin detects a falling edge (when the pin's voltage transitions from HIGH to LOW), a rising edge (when the pin's voltage transitions from LOW to HIGH), or any transition of state on the pin.  <a href="classembed_1_1interrupt__pin.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structembed_1_1i2c__settings.html">i2c_settings</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Generic settings for a standard I2C device.  <a href="structembed_1_1i2c__settings.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classembed_1_1i2c.html">i2c</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Inter-integrated Circuit (I2C) or Two Wire Interface (TWI) communication protocol hardware abstract interface.  <a href="classembed_1_1i2c.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classembed_1_1pwm.html">pwm</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Pulse Width Modulation (PWM) channel hardware abstraction.  <a href="classembed_1_1pwm.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structembed_1_1serial__settings.html">serial_settings</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Generic settings for a standard serial device.  <a href="structembed_1_1serial__settings.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classembed_1_1serial.html">serial</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Serial communication protocol hardware abstract interface. Use this interface for hardware that implements a serial protocol like UART, USART, RS232, RS485 and many others that use a similar communication protocol but may use different voltage schemes.  <a href="classembed_1_1serial.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structembed_1_1spi__settings.html">spi_settings</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Generic settings for a standard SPI device.  <a href="structembed_1_1spi__settings.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classembed_1_1spi.html">spi</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Serial peripheral interface (SPI) communication protocol hardware abstract interface.  <a href="classembed_1_1spi.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classembed_1_1static__callable.html">static_callable</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">General class which will be used to allow for signature to be used and then split by the below class.  <a href="classembed_1_1static__callable.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classembed_1_1static__callable_3_01owner__class_00_01reference__designator_00_01return__t_07args__t_8_8_8_08_4.html">static_callable&lt; owner_class, reference_designator, return_t(args_t...)&gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Specialization of <a class="el" href="classembed_1_1static__callable.html" title="General class which will be used to allow for signature to be used and then split by the below class.">static_callable</a> with the return type and arguments split up.  <a href="classembed_1_1static__callable_3_01owner__class_00_01reference__designator_00_01return__t_07args__t_8_8_8_08_4.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classembed_1_1static__memory__resource.html">static_memory_resource</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">The <a class="el" href="classembed_1_1static__memory__resource.html" title="The static_memory_resource is the polymorphic memory resource allocator that allows libembeddedhal&#39;s ...">static_memory_resource</a> is the polymorphic memory resource allocator that allows libembeddedhal's libraries to use a C++ standard container such as std::pmr::vector, std::pmr::string, std::pmr::unordered_map, and more without requiring dynamic memory allocation from the heap. It provides a simple way to create an allocator with built in storage, with its size indicated by a single template parameter. It also provides statistics regarding the amount of memory allocated such that developers can determine if they need to reduce or increase the size of the buffer. Memory statistics can also give programs the insight into how much memory space is available and make decisions based on that. In the event that the memory of the static allocator is exceeded, a std::bad_alloc excpetion is thrown.  <a href="classembed_1_1static__memory__resource.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classembed_1_1timer.html">timer</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Timer hardware abstraction interface. Use this interface for devices and peripherals that have timer like capabilities, such that, when a timer's time has expired, an event/interrupt/signal is generated.  <a href="classembed_1_1timer.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="enum-members"></a>
Enumerations</h2></td></tr>
<tr class="memitem:a5ab6b9e7ccdd68ae6b998c8b586a75a6"><td class="memItemLeft" align="right" valign="top">enum class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceembed.html#a5ab6b9e7ccdd68ae6b998c8b586a75a6">pin_resistor</a> { <a class="el" href="namespaceembed.html#a5ab6b9e7ccdd68ae6b998c8b586a75a6a334c4a4c42fdb79d7ebc3e73b517e6f8">none</a> = 0
, <a class="el" href="namespaceembed.html#a5ab6b9e7ccdd68ae6b998c8b586a75a6a6bd95a5bd1a571a29b57aa0dfda9d77b">pull_down</a>
, <a class="el" href="namespaceembed.html#a5ab6b9e7ccdd68ae6b998c8b586a75a6a5dd40e1f7d5c287d1df85dac013c1c38">pull_up</a>
 }</td></tr>
<tr class="memdesc:a5ab6b9e7ccdd68ae6b998c8b586a75a6"><td class="mdescLeft">&#160;</td><td class="mdescRight">Set of possible pin mode resistor settings. See each enumeration to get more details about when and how these should be used.  <a href="namespaceembed.html#a5ab6b9e7ccdd68ae6b998c8b586a75a6">More...</a><br /></td></tr>
<tr class="separator:a5ab6b9e7ccdd68ae6b998c8b586a75a6"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="func-members"></a>
Functions</h2></td></tr>
<tr class="memitem:aea8ad233b7538689ad6f63d629743222"><td class="memItemLeft" align="right" valign="top">constexpr bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceembed.html#aea8ad233b7538689ad6f63d629743222">is_platform</a> (std::string_view p_platform)</td></tr>
<tr class="memdesc:aea8ad233b7538689ad6f63d629743222"><td class="mdescLeft">&#160;</td><td class="mdescRight">Determines if the current application was built for a specific platform. For example:  <a href="namespaceembed.html#aea8ad233b7538689ad6f63d629743222">More...</a><br /></td></tr>
<tr class="separator:aea8ad233b7538689ad6f63d629743222"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a34fb9ef716de27d60ec74784b0a16307"><td class="memItemLeft" align="right" valign="top">constexpr bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceembed.html#a34fb9ef716de27d60ec74784b0a16307">is_a_test</a> ()</td></tr>
<tr class="memdesc:a34fb9ef716de27d60ec74784b0a16307"><td class="mdescLeft">&#160;</td><td class="mdescRight">Determines if the application is a test.  <a href="namespaceembed.html#a34fb9ef716de27d60ec74784b0a16307">More...</a><br /></td></tr>
<tr class="separator:a34fb9ef716de27d60ec74784b0a16307"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:adb81fed604e4119c9318e47024eeb4b3"><td class="memTemplParams" colspan="2">template&lt;typename enum_type &gt; </td></tr>
<tr class="memitem:adb81fed604e4119c9318e47024eeb4b3"><td class="memTemplItemLeft" align="right" valign="top">constexpr auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceembed.html#adb81fed604e4119c9318e47024eeb4b3">value</a> (enum_type enum_value)</td></tr>
<tr class="memdesc:adb81fed604e4119c9318e47024eeb4b3"><td class="mdescLeft">&#160;</td><td class="mdescRight">Helper function to convert an enum to its integral value.  <a href="namespaceembed.html#adb81fed604e4119c9318e47024eeb4b3">More...</a><br /></td></tr>
<tr class="separator:adb81fed604e4119c9318e47024eeb4b3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a275d9ea59b830bbabfb5cd33e3d1426d"><td class="memTemplParams" colspan="2">template&lt;std::unsigned_integral T, std::unsigned_integral U&gt; </td></tr>
<tr class="memitem:a275d9ea59b830bbabfb5cd33e3d1426d"><td class="memTemplItemLeft" align="right" valign="top">auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceembed.html#a275d9ea59b830bbabfb5cd33e3d1426d">operator*</a> (U <a class="el" href="namespaceembed.html#adb81fed604e4119c9318e47024eeb4b3">value</a>, <a class="el" href="classembed_1_1full__scale.html">full_scale</a>&lt; T &gt; scale)</td></tr>
<tr class="separator:a275d9ea59b830bbabfb5cd33e3d1426d"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="var-members"></a>
Variables</h2></td></tr>
<tr class="memitem:a0c3a3fccb52284cef1b912f6c2c4c5cc"><td class="memItemLeft" align="right" valign="top">constexpr const std::string_view&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceembed.html#a0c3a3fccb52284cef1b912f6c2c4c5cc">platform_string</a> = <a class="el" href="context_8hpp.html#a786d51023bf2ededed548bb861d49aa9">PLATFORM_STRING</a></td></tr>
<tr class="memdesc:a0c3a3fccb52284cef1b912f6c2c4c5cc"><td class="mdescLeft">&#160;</td><td class="mdescRight">The platform string determines which platform this application was built for. Use this to determine at compile or runtime if the running application is a "test", an "lpc40" series mcu, and "stm" series mcu or a raspberry pi ("rpi").  <a href="namespaceembed.html#a0c3a3fccb52284cef1b912f6c2c4c5cc">More...</a><br /></td></tr>
<tr class="separator:a0c3a3fccb52284cef1b912f6c2c4c5cc"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a987ef4ed606ec89c1e19cce294309efe"><td class="memTemplParams" colspan="2">template&lt;auto... options&gt; </td></tr>
<tr class="memitem:a987ef4ed606ec89c1e19cce294309efe"><td class="memTemplItemLeft" align="right" valign="top">constexpr bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceembed.html#a987ef4ed606ec89c1e19cce294309efe">invalid_option</a> = <a class="el" href="structembed_1_1invalid__option__t.html">invalid_option_t</a>&lt;options...&gt;::<a class="el" href="namespaceembed.html#adb81fed604e4119c9318e47024eeb4b3">value</a></td></tr>
<tr class="memdesc:a987ef4ed606ec89c1e19cce294309efe"><td class="mdescLeft">&#160;</td><td class="mdescRight">Helper definition to simplify the usage of <a class="el" href="structembed_1_1invalid__option__t.html" title="Used for defining static_asserts that should always fail, but only if the static_assert line is hit v...">invalid_option_t</a>.  <a href="namespaceembed.html#a987ef4ed606ec89c1e19cce294309efe">More...</a><br /></td></tr>
<tr class="separator:a987ef4ed606ec89c1e19cce294309efe"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<h2 class="groupheader">Enumeration Type Documentation</h2>
<a id="a5ab6b9e7ccdd68ae6b998c8b586a75a6"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5ab6b9e7ccdd68ae6b998c8b586a75a6">&#9670;&nbsp;</a></span>pin_resistor</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">enum <a class="el" href="namespaceembed.html#a5ab6b9e7ccdd68ae6b998c8b586a75a6">embed::pin_resistor</a></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">strong</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Set of possible pin mode resistor settings. See each enumeration to get more details about when and how these should be used. </p>
<table class="fieldtable">
<tr><th colspan="2">Enumerator</th></tr><tr><td class="fieldname"><a id="a5ab6b9e7ccdd68ae6b998c8b586a75a6a334c4a4c42fdb79d7ebc3e73b517e6f8"></a>none&#160;</td><td class="fielddoc"><p>No pull up. This will cause the pin to float. This may be desirable if the pin has an external resistor attached or if the signal is sensitive to external devices like resistors. </p>
</td></tr>
<tr><td class="fieldname"><a id="a5ab6b9e7ccdd68ae6b998c8b586a75a6a6bd95a5bd1a571a29b57aa0dfda9d77b"></a>pull_down&#160;</td><td class="fielddoc"><p>Pull the pin down to devices GND. This will ensure that the voltage read by the pin when there is no signal on the pin is LOW (or false). </p>
</td></tr>
<tr><td class="fieldname"><a id="a5ab6b9e7ccdd68ae6b998c8b586a75a6a5dd40e1f7d5c287d1df85dac013c1c38"></a>pull_up&#160;</td><td class="fielddoc"><p>See pull down explanation, but in this case the pin is pulled up to VCC, also called VDD on some systems. </p>
</td></tr>
</table>

</div>
</div>
<h2 class="groupheader">Function Documentation</h2>
<a id="a34fb9ef716de27d60ec74784b0a16307"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a34fb9ef716de27d60ec74784b0a16307">&#9670;&nbsp;</a></span>is_a_test()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr bool embed::is_a_test </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">constexpr</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Determines if the application is a test. </p>
<dl class="section return"><dt>Returns</dt><dd>true this application is a test </dd>
<dd>
false this application is not a test </dd></dl>

</div>
</div>
<a id="aea8ad233b7538689ad6f63d629743222"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aea8ad233b7538689ad6f63d629743222">&#9670;&nbsp;</a></span>is_platform()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr bool embed::is_platform </td>
          <td>(</td>
          <td class="paramtype">std::string_view&#160;</td>
          <td class="paramname"><em>p_platform</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">constexpr</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Determines if the current application was built for a specific platform. For example: </p>
<p><a class="el" href="namespaceembed.html#aea8ad233b7538689ad6f63d629743222" title="Determines if the current application was built for a specific platform. For example:">embed::is_platform</a>("lpc4078");</p>
<p>Will return true if the PLATFORM macro defined at compile time was equal to lpc4078. If the developer wants to be less specific, let say, to just determine if the platform is in the lpc40xx family then the following example will work.</p>
<p><a class="el" href="namespaceembed.html#aea8ad233b7538689ad6f63d629743222" title="Determines if the current application was built for a specific platform. For example:">embed::is_platform</a>("lpc40");</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">p_platform</td><td>platform string pattern to check against </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>true matches the platform string </dd>
<dd>
false does not matches the platform string </dd></dl>

</div>
</div>
<a id="a275d9ea59b830bbabfb5cd33e3d1426d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a275d9ea59b830bbabfb5cd33e3d1426d">&#9670;&nbsp;</a></span>operator*()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;std::unsigned_integral T, std::unsigned_integral U&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">auto embed::operator* </td>
          <td>(</td>
          <td class="paramtype">U&#160;</td>
          <td class="paramname"><em>value</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classembed_1_1full__scale.html">full_scale</a>&lt; T &gt;&#160;</td>
          <td class="paramname"><em>scale</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">T</td><td></td></tr>
    <tr><td class="paramname">U</td><td></td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">value</td><td></td></tr>
    <tr><td class="paramname">scale</td><td></td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>auto </dd></dl>

</div>
</div>
<a id="adb81fed604e4119c9318e47024eeb4b3"></a>
<h2 class="memtitle"><span class="permalink"><a href="#adb81fed604e4119c9318e47024eeb4b3">&#9670;&nbsp;</a></span>value()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename enum_type &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr auto embed::value </td>
          <td>(</td>
          <td class="paramtype">enum_type&#160;</td>
          <td class="paramname"><em>enum_value</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">constexpr</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Helper function to convert an enum to its integral value. </p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">enum_type</td><td>the underlying type of the enumeration. Do not supply this value, it is inferred by the enum_value passed to the function. </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">enum_value</td><td>the enumeration you want to convert into an integral value </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>constexpr auto return the integral value of the enum. </dd></dl>

</div>
</div>
<h2 class="groupheader">Variable Documentation</h2>
<a id="a987ef4ed606ec89c1e19cce294309efe"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a987ef4ed606ec89c1e19cce294309efe">&#9670;&nbsp;</a></span>invalid_option</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;auto... options&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr bool embed::invalid_option = <a class="el" href="structembed_1_1invalid__option__t.html">invalid_option_t</a>&lt;options...&gt;::<a class="el" href="namespaceembed.html#adb81fed604e4119c9318e47024eeb4b3">value</a></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">constexpr</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Helper definition to simplify the usage of <a class="el" href="structembed_1_1invalid__option__t.html" title="Used for defining static_asserts that should always fail, but only if the static_assert line is hit v...">invalid_option_t</a>. </p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">options</td><td>ignored by the application but needed to create a non-trivial specialization of this class which allows its usage in static_assert. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a0c3a3fccb52284cef1b912f6c2c4c5cc"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0c3a3fccb52284cef1b912f6c2c4c5cc">&#9670;&nbsp;</a></span>platform_string</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr const std::string_view embed::platform_string = <a class="el" href="context_8hpp.html#a786d51023bf2ededed548bb861d49aa9">PLATFORM_STRING</a></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">constexpr</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>The platform string determines which platform this application was built for. Use this to determine at compile or runtime if the running application is a "test", an "lpc40" series mcu, and "stm" series mcu or a raspberry pi ("rpi"). </p>

</div>
</div>
</div><!-- contents -->
<!-- start footer part -->
<hr class="footer"/><address class="footer"><small>
Generated by&#160;<a href="https://www.doxygen.org/index.html"><img class="footer" src="doxygen.svg" width="104" height="31" alt="doxygen"/></a> 1.9.1
</small></address>
</body>
</html>
