<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "https://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.9.1"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>libembeddedhal API: embed::counter Class Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectalign" style="padding-left: 0.5em;">
   <div id="projectname">libembeddedhal API
   </div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.9.1 -->
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
var searchBox = new SearchBox("searchBox", "search",false,'Search','.html');
/* @license-end */
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
$(function() {
  initMenu('',true,false,'search.php','Search');
  $(document).ready(function() { init_search(); });
});
/* @license-end */</script>
<div id="main-nav"></div>
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

<div id="nav-path" class="navpath">
  <ul>
<li class="navelem"><a class="el" href="namespaceembed.html">embed</a></li><li class="navelem"><a class="el" href="classembed_1_1counter.html">counter</a></li>  </ul>
</div>
</div><!-- top -->
<div class="header">
  <div class="summary">
<a href="#pub-types">Public Types</a> &#124;
<a href="#pub-methods">Public Member Functions</a> &#124;
<a href="classembed_1_1counter-members.html">List of all members</a>  </div>
  <div class="headertitle">
<div class="title">embed::counter Class Reference<span class="mlabels"><span class="mlabel">abstract</span></span></div>  </div>
</div><!--header-->
<div class="contents">

<p>Counter hardware abstraction interface. Use this interface for devices and peripherals that have counting capabilities. Such devices can count up or down. Useful for keeping time. Expect counters to overflow when they reach the end of counting register's limits.  
 <a href="classembed_1_1counter.html#details">More...</a></p>

<p><code>#include &lt;<a class="el" href="counter_8hpp_source.html">counter.hpp</a>&gt;</code></p>
<div class="dynheader">
Inheritance diagram for embed::counter:</div>
<div class="dyncontent">
<div class="center"><iframe scrolling="no" frameborder="0" src="classembed_1_1counter__inherit__graph.svg" width="190" height="112"><p><b>This browser is not able to show SVG: try Firefox, Chrome, Safari, or Opera instead.</b></p></iframe>
</div>
<center><span class="legend">[<a href="graph_legend.html">legend</a>]</span></center></div>
<div class="dynheader">
Collaboration diagram for embed::counter:</div>
<div class="dyncontent">
<div class="center"><iframe scrolling="no" frameborder="0" src="classembed_1_1counter__coll__graph.svg" width="228" height="218"><p><b>This browser is not able to show SVG: try Firefox, Chrome, Safari, or Opera instead.</b></p></iframe>
</div>
<center><span class="legend">[<a href="graph_legend.html">legend</a>]</span></center></div>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pub-types"></a>
Public Types</h2></td></tr>
<tr class="memitem:a4c1aba30af1ec98a9a67d9e272fdb896"><td class="memItemLeft" align="right" valign="top">enum class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classembed_1_1counter.html#a4c1aba30af1ec98a9a67d9e272fdb896">controls</a> { <a class="el" href="classembed_1_1counter.html#a4c1aba30af1ec98a9a67d9e272fdb896aea2b2676c28c0db26d39331a336c6b92">start</a>
, <a class="el" href="classembed_1_1counter.html#a4c1aba30af1ec98a9a67d9e272fdb896aef399b2d446bb37b7c32ad2cc1b6045b">stop</a>
, <a class="el" href="classembed_1_1counter.html#a4c1aba30af1ec98a9a67d9e272fdb896a86266ee937d97f812a8e57d22b62ee29">reset</a>
 }</td></tr>
<tr class="memdesc:a4c1aba30af1ec98a9a67d9e272fdb896"><td class="mdescLeft">&#160;</td><td class="mdescRight">Set of controls for a counter.  <a href="classembed_1_1counter.html#a4c1aba30af1ec98a9a67d9e272fdb896">More...</a><br /></td></tr>
<tr class="separator:a4c1aba30af1ec98a9a67d9e272fdb896"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pub-methods"></a>
Public Member Functions</h2></td></tr>
<tr class="memitem:a1be2b2ccf263b691869efb7faeceac00"><td class="memItemLeft" align="right" valign="top">virtual bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classembed_1_1counter.html#a1be2b2ccf263b691869efb7faeceac00">is_running</a> ()=0</td></tr>
<tr class="memdesc:a1be2b2ccf263b691869efb7faeceac00"><td class="mdescLeft">&#160;</td><td class="mdescRight">Determine if the counter is currently running.  <a href="classembed_1_1counter.html#a1be2b2ccf263b691869efb7faeceac00">More...</a><br /></td></tr>
<tr class="separator:a1be2b2ccf263b691869efb7faeceac00"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab2689e7eaab22afbf67faccf85f0bb31"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classembed_1_1counter.html#ab2689e7eaab22afbf67faccf85f0bb31">control</a> (<a class="el" href="classembed_1_1counter.html#a4c1aba30af1ec98a9a67d9e272fdb896">controls</a> p_control)=0</td></tr>
<tr class="memdesc:ab2689e7eaab22afbf67faccf85f0bb31"><td class="mdescLeft">&#160;</td><td class="mdescRight">Control the state of the counter.  <a href="classembed_1_1counter.html#ab2689e7eaab22afbf67faccf85f0bb31">More...</a><br /></td></tr>
<tr class="separator:ab2689e7eaab22afbf67faccf85f0bb31"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7c96f78693ea3037a5f3414f1cb4b3d2"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classembed_1_1counter.html#a7c96f78693ea3037a5f3414f1cb4b3d2">period</a> (std::chrono::nanoseconds p_period)=0</td></tr>
<tr class="memdesc:a7c96f78693ea3037a5f3414f1cb4b3d2"><td class="mdescLeft">&#160;</td><td class="mdescRight">Period for each count of the timer. For example a period of 1ms and a count of 500 would mean that 500ms has elapse since the counter has been started.  <a href="classembed_1_1counter.html#a7c96f78693ea3037a5f3414f1cb4b3d2">More...</a><br /></td></tr>
<tr class="separator:a7c96f78693ea3037a5f3414f1cb4b3d2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3c275a38f1242bab8a05a47410ec09bc"><td class="memItemLeft" align="right" valign="top">virtual std::chrono::nanoseconds&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classembed_1_1counter.html#a3c275a38f1242bab8a05a47410ec09bc">period</a> ()=0</td></tr>
<tr class="memdesc:a3c275a38f1242bab8a05a47410ec09bc"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get the current period for the counter.  <a href="classembed_1_1counter.html#a3c275a38f1242bab8a05a47410ec09bc">More...</a><br /></td></tr>
<tr class="separator:a3c275a38f1242bab8a05a47410ec09bc"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a54d3fb7657d6a128533d4b7c61900b55"><td class="memItemLeft" align="right" valign="top">virtual uint64_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classembed_1_1counter.html#a54d3fb7657d6a128533d4b7c61900b55">count</a> ()=0</td></tr>
<tr class="memdesc:a54d3fb7657d6a128533d4b7c61900b55"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get the count of the counter.  <a href="classembed_1_1counter.html#a54d3fb7657d6a128533d4b7c61900b55">More...</a><br /></td></tr>
<tr class="separator:a54d3fb7657d6a128533d4b7c61900b55"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="inherit_header pub_methods_classembed_1_1driver"><td colspan="2" onclick="javascript:toggleInherit('pub_methods_classembed_1_1driver')"><img src="closed.png" alt="-"/>&#160;Public Member Functions inherited from <a class="el" href="classembed_1_1driver.html">embed::driver&lt; settings_t &gt;</a></td></tr>
<tr class="memitem:a947a3487fa3acd0879e83872d9c97b01 inherit pub_methods_classembed_1_1driver"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classembed_1_1driver.html#a947a3487fa3acd0879e83872d9c97b01">initialize</a> ()</td></tr>
<tr class="memdesc:a947a3487fa3acd0879e83872d9c97b01 inherit pub_methods_classembed_1_1driver"><td class="mdescLeft">&#160;</td><td class="mdescRight">Initialize the driver, apply the setting as defined in the settings_t structure and enable it. Calling this function after it has already been initialized will return false. In order to run initialization again, <a class="el" href="classembed_1_1driver.html#a54440bf23c0c34102f563da1193d99ae" title="Reset the driver in order to run initialize again. This is helpful if the application needs to change...">reset()</a> must be called. After initialization, the settings are committed and saved into another settings structure. This settings can be looked up and inspected by the application.  <a href="classembed_1_1driver.html#a947a3487fa3acd0879e83872d9c97b01">More...</a><br /></td></tr>
<tr class="separator:a947a3487fa3acd0879e83872d9c97b01 inherit pub_methods_classembed_1_1driver"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a54440bf23c0c34102f563da1193d99ae inherit pub_methods_classembed_1_1driver"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classembed_1_1driver.html#a54440bf23c0c34102f563da1193d99ae">reset</a> ()</td></tr>
<tr class="memdesc:a54440bf23c0c34102f563da1193d99ae inherit pub_methods_classembed_1_1driver"><td class="mdescLeft">&#160;</td><td class="mdescRight">Reset the driver in order to run initialize again. This is helpful if the application needs to change the settings of a driver after it is first initialized, like baud rate for serial or pull resistor for a pin.  <a href="classembed_1_1driver.html#a54440bf23c0c34102f563da1193d99ae">More...</a><br /></td></tr>
<tr class="separator:a54440bf23c0c34102f563da1193d99ae inherit pub_methods_classembed_1_1driver"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a346f472e8c212d09c8f45aebd0089d7b inherit pub_methods_classembed_1_1driver"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classembed_1_1driver.html#a346f472e8c212d09c8f45aebd0089d7b">is_initialized</a> () const</td></tr>
<tr class="memdesc:a346f472e8c212d09c8f45aebd0089d7b inherit pub_methods_classembed_1_1driver"><td class="mdescLeft">&#160;</td><td class="mdescRight">Determine if the driver has been initialized.  <a href="classembed_1_1driver.html#a346f472e8c212d09c8f45aebd0089d7b">More...</a><br /></td></tr>
<tr class="separator:a346f472e8c212d09c8f45aebd0089d7b inherit pub_methods_classembed_1_1driver"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae6eb991ebb2321bb3565c2a03a613219 inherit pub_methods_classembed_1_1driver"><td class="memItemLeft" align="right" valign="top">settings_t &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classembed_1_1driver.html#ae6eb991ebb2321bb3565c2a03a613219">settings</a> ()</td></tr>
<tr class="memdesc:ae6eb991ebb2321bb3565c2a03a613219 inherit pub_methods_classembed_1_1driver"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get access to uncommitted driver settings.  <a href="classembed_1_1driver.html#ae6eb991ebb2321bb3565c2a03a613219">More...</a><br /></td></tr>
<tr class="separator:ae6eb991ebb2321bb3565c2a03a613219 inherit pub_methods_classembed_1_1driver"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7e13fe8999142475da8c5b84927f03aa inherit pub_methods_classembed_1_1driver"><td class="memItemLeft" align="right" valign="top">const settings_t &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classembed_1_1driver.html#a7e13fe8999142475da8c5b84927f03aa">initialized_settings</a> () const</td></tr>
<tr class="memdesc:a7e13fe8999142475da8c5b84927f03aa inherit pub_methods_classembed_1_1driver"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get access to the settings that were used in the latest initialization. These settings only get updated when a successful <a class="el" href="classembed_1_1driver.html#a947a3487fa3acd0879e83872d9c97b01" title="Initialize the driver, apply the setting as defined in the settings_t structure and enable it....">initialize()</a> has occurred.  <a href="classembed_1_1driver.html#a7e13fe8999142475da8c5b84927f03aa">More...</a><br /></td></tr>
<tr class="separator:a7e13fe8999142475da8c5b84927f03aa inherit pub_methods_classembed_1_1driver"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="inherited"></a>
Additional Inherited Members</h2></td></tr>
<tr class="inherit_header pro_methods_classembed_1_1driver"><td colspan="2" onclick="javascript:toggleInherit('pro_methods_classembed_1_1driver')"><img src="closed.png" alt="-"/>&#160;Protected Member Functions inherited from <a class="el" href="classembed_1_1driver.html">embed::driver&lt; settings_t &gt;</a></td></tr>
<tr class="memitem:a1677362481d10c3b48544359daadf081 inherit pro_methods_classembed_1_1driver"><td class="memItemLeft" align="right" valign="top">virtual bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classembed_1_1driver.html#a1677362481d10c3b48544359daadf081">driver_initialize</a> ()=0</td></tr>
<tr class="separator:a1677362481d10c3b48544359daadf081 inherit pro_methods_classembed_1_1driver"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="inherit_header pro_attribs_classembed_1_1driver"><td colspan="2" onclick="javascript:toggleInherit('pro_attribs_classembed_1_1driver')"><img src="closed.png" alt="-"/>&#160;Protected Attributes inherited from <a class="el" href="classembed_1_1driver.html">embed::driver&lt; settings_t &gt;</a></td></tr>
<tr class="memitem:afb925433a5897293609af5fae29e3dc3 inherit pro_attribs_classembed_1_1driver"><td class="memItemLeft" align="right" valign="top">settings_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classembed_1_1driver.html#afb925433a5897293609af5fae29e3dc3">m_settings</a> {}</td></tr>
<tr class="separator:afb925433a5897293609af5fae29e3dc3 inherit pro_attribs_classembed_1_1driver"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aac7d23e384bc27a26b77c8fd681483ef inherit pro_attribs_classembed_1_1driver"><td class="memItemLeft" align="right" valign="top">settings_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classembed_1_1driver.html#aac7d23e384bc27a26b77c8fd681483ef">m_initialized_settings</a> {}</td></tr>
<tr class="separator:aac7d23e384bc27a26b77c8fd681483ef inherit pro_attribs_classembed_1_1driver"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab8b2029f33d55b9ffffd6e88d846cd7b inherit pro_attribs_classembed_1_1driver"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classembed_1_1driver.html#ab8b2029f33d55b9ffffd6e88d846cd7b">m_initialized</a> = false</td></tr>
<tr class="separator:ab8b2029f33d55b9ffffd6e88d846cd7b inherit pro_attribs_classembed_1_1driver"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<div class="textblock"><p>Counter hardware abstraction interface. Use this interface for devices and peripherals that have counting capabilities. Such devices can count up or down. Useful for keeping time. Expect counters to overflow when they reach the end of counting register's limits. </p>
</div><h2 class="groupheader">Member Enumeration Documentation</h2>
<a id="a4c1aba30af1ec98a9a67d9e272fdb896"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4c1aba30af1ec98a9a67d9e272fdb896">&#9670;&nbsp;</a></span>controls</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">enum <a class="el" href="classembed_1_1counter.html#a4c1aba30af1ec98a9a67d9e272fdb896">embed::counter::controls</a></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">strong</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Set of controls for a counter. </p>
<table class="fieldtable">
<tr><th colspan="2">Enumerator</th></tr><tr><td class="fieldname"><a id="a4c1aba30af1ec98a9a67d9e272fdb896aea2b2676c28c0db26d39331a336c6b92"></a>start&#160;</td><td class="fielddoc"><p>Control value to start the counter. </p>
</td></tr>
<tr><td class="fieldname"><a id="a4c1aba30af1ec98a9a67d9e272fdb896aef399b2d446bb37b7c32ad2cc1b6045b"></a>stop&#160;</td><td class="fielddoc"><p>Control value to stop a counter. </p>
</td></tr>
<tr><td class="fieldname"><a id="a4c1aba30af1ec98a9a67d9e272fdb896a86266ee937d97f812a8e57d22b62ee29"></a>reset&#160;</td><td class="fielddoc"><p>Control value to reset a counter. The counter shall remain in a running or stopped state after this call. So an ongoing counter will continue to count but will have its counter reset to zero if this control is used. If a counter is stopped, then it shall be reset to zero, and stay stopped. </p>
</td></tr>
</table>

</div>
</div>
<h2 class="groupheader">Member Function Documentation</h2>
<a id="ab2689e7eaab22afbf67faccf85f0bb31"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab2689e7eaab22afbf67faccf85f0bb31">&#9670;&nbsp;</a></span>control()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual void embed::counter::control </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classembed_1_1counter.html#a4c1aba30af1ec98a9a67d9e272fdb896">controls</a>&#160;</td>
          <td class="paramname"><em>p_control</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">pure virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Control the state of the counter. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">p_control</td><td>new state for the counter </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a54d3fb7657d6a128533d4b7c61900b55"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a54d3fb7657d6a128533d4b7c61900b55">&#9670;&nbsp;</a></span>count()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual uint64_t embed::counter::count </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">pure virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Get the count of the counter. </p>
<dl class="section return"><dt>Returns</dt><dd>uint64_t current count </dd></dl>

</div>
</div>
<a id="a1be2b2ccf263b691869efb7faeceac00"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1be2b2ccf263b691869efb7faeceac00">&#9670;&nbsp;</a></span>is_running()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual bool embed::counter::is_running </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">pure virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Determine if the counter is currently running. </p>
<dl class="section return"><dt>Returns</dt><dd>true counter is currently running </dd>
<dd>
false counter is currently stopped </dd></dl>

</div>
</div>
<a id="a3c275a38f1242bab8a05a47410ec09bc"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3c275a38f1242bab8a05a47410ec09bc">&#9670;&nbsp;</a></span>period() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual std::chrono::nanoseconds embed::counter::period </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">pure virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Get the current period for the counter. </p>
<dl class="section return"><dt>Returns</dt><dd>std::chrono::nanoseconds </dd></dl>

</div>
</div>
<a id="a7c96f78693ea3037a5f3414f1cb4b3d2"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7c96f78693ea3037a5f3414f1cb4b3d2">&#9670;&nbsp;</a></span>period() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual void embed::counter::period </td>
          <td>(</td>
          <td class="paramtype">std::chrono::nanoseconds&#160;</td>
          <td class="paramname"><em>p_period</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">pure virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Period for each count of the timer. For example a period of 1ms and a count of 500 would mean that 500ms has elapse since the counter has been started. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">p_period</td><td>the amount of time each count should be. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<hr/>The documentation for this class was generated from the following file:<ul>
<li>/github/workspace/include/libembeddedhal/counter/<a class="el" href="counter_8hpp_source.html">counter.hpp</a></li>
</ul>
</div><!-- contents -->
<!-- start footer part -->
<hr class="footer"/><address class="footer"><small>
Generated by&#160;<a href="https://www.doxygen.org/index.html"><img class="footer" src="doxygen.svg" width="104" height="31" alt="doxygen"/></a> 1.9.1
</small></address>
</body>
</html>
