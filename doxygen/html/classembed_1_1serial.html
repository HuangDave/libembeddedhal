<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "https://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.9.1"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>libembeddedhal API: embed::serial Class Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectalign" style="padding-left: 0.5em;">
   <div id="projectname">libembeddedhal API
   </div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.9.1 -->
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
var searchBox = new SearchBox("searchBox", "search",false,'Search','.html');
/* @license-end */
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
$(function() {
  initMenu('',true,false,'search.php','Search');
  $(document).ready(function() { init_search(); });
});
/* @license-end */</script>
<div id="main-nav"></div>
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

<div id="nav-path" class="navpath">
  <ul>
<li class="navelem"><a class="el" href="namespaceembed.html">embed</a></li><li class="navelem"><a class="el" href="classembed_1_1serial.html">serial</a></li>  </ul>
</div>
</div><!-- top -->
<div class="header">
  <div class="summary">
<a href="#pub-methods">Public Member Functions</a> &#124;
<a href="classembed_1_1serial-members.html">List of all members</a>  </div>
  <div class="headertitle">
<div class="title">embed::serial Class Reference<span class="mlabels"><span class="mlabel">abstract</span></span></div>  </div>
</div><!--header-->
<div class="contents">

<p>Serial communication protocol hardware abstract interface. Use this interface for hardware that implements a serial protocol like UART, USART, RS232, RS485 and many others that use a similar communication protocol but may use different voltage schemes.  
 <a href="classembed_1_1serial.html#details">More...</a></p>

<p><code>#include &lt;<a class="el" href="serial_8hpp_source.html">serial.hpp</a>&gt;</code></p>
<div class="dynheader">
Inheritance diagram for embed::serial:</div>
<div class="dyncontent">
<div class="center"><iframe scrolling="no" frameborder="0" src="classembed_1_1serial__inherit__graph.svg" width="152" height="127"><p><b>This browser is not able to show SVG: try Firefox, Chrome, Safari, or Opera instead.</b></p></iframe>
</div>
<center><span class="legend">[<a href="graph_legend.html">legend</a>]</span></center></div>
<div class="dynheader">
Collaboration diagram for embed::serial:</div>
<div class="dyncontent">
<div class="center"><iframe scrolling="no" frameborder="0" src="classembed_1_1serial__coll__graph.svg" width="152" height="127"><p><b>This browser is not able to show SVG: try Firefox, Chrome, Safari, or Opera instead.</b></p></iframe>
</div>
<center><span class="legend">[<a href="graph_legend.html">legend</a>]</span></center></div>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pub-methods"></a>
Public Member Functions</h2></td></tr>
<tr class="memitem:a2632150facd5b70f49dedea7108679d6"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classembed_1_1serial.html#a2632150facd5b70f49dedea7108679d6">write</a> (std::span&lt; const std::byte &gt; p_data)=0</td></tr>
<tr class="memdesc:a2632150facd5b70f49dedea7108679d6"><td class="mdescLeft">&#160;</td><td class="mdescRight">Write data on the transmitter line of the port. The exact implementation for this can be polling, interrupt driven or DMA driven. There is no guarantee on exactly how a write operation will operate, thus the <a class="el" href="classembed_1_1serial.html#acaa9db822945c72a220f2ca7c4c03ab9" title="Determines if the write operation is currently on going.">busy()</a> function must polled called after this returns to determine if the write operation has finished. Attempting to call <a class="el" href="classembed_1_1serial.html#a2632150facd5b70f49dedea7108679d6" title="Write data on the transmitter line of the port. The exact implementation for this can be polling,...">write()</a> when tranmission is busy is undefined behavior.  <a href="classembed_1_1serial.html#a2632150facd5b70f49dedea7108679d6">More...</a><br /></td></tr>
<tr class="separator:a2632150facd5b70f49dedea7108679d6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:acaa9db822945c72a220f2ca7c4c03ab9"><td class="memItemLeft" align="right" valign="top">virtual bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classembed_1_1serial.html#acaa9db822945c72a220f2ca7c4c03ab9">busy</a> ()=0</td></tr>
<tr class="memdesc:acaa9db822945c72a220f2ca7c4c03ab9"><td class="mdescLeft">&#160;</td><td class="mdescRight">Determines if the write operation is currently on going.  <a href="classembed_1_1serial.html#acaa9db822945c72a220f2ca7c4c03ab9">More...</a><br /></td></tr>
<tr class="separator:acaa9db822945c72a220f2ca7c4c03ab9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a01006e49540c953a3bbc7bdfcb9d05c6"><td class="memItemLeft" align="right" valign="top">virtual size_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classembed_1_1serial.html#a01006e49540c953a3bbc7bdfcb9d05c6">bytes_available</a> ()=0</td></tr>
<tr class="memdesc:a01006e49540c953a3bbc7bdfcb9d05c6"><td class="mdescLeft">&#160;</td><td class="mdescRight">The number of bytes that have been buffered. For frames less than 8-bits, each byte holds a frame. For frames above 8-bits the number of bytes returned indicates the number of bytes a buffer needs to be to return all of the data held in the buffer.  <a href="classembed_1_1serial.html#a01006e49540c953a3bbc7bdfcb9d05c6">More...</a><br /></td></tr>
<tr class="separator:a01006e49540c953a3bbc7bdfcb9d05c6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aff1745f3944aaaf9d467257db7a8282a"><td class="memItemLeft" align="right" valign="top">virtual std::span&lt; const std::byte &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classembed_1_1serial.html#aff1745f3944aaaf9d467257db7a8282a">read</a> (std::span&lt; std::byte &gt; p_data)=0</td></tr>
<tr class="memdesc:aff1745f3944aaaf9d467257db7a8282a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Read the bytes received over the ports receiver line and stored in the serial implementations buffer. The number of bytes read will subtract the number of bytes available until it reaches zero.  <a href="classembed_1_1serial.html#aff1745f3944aaaf9d467257db7a8282a">More...</a><br /></td></tr>
<tr class="separator:aff1745f3944aaaf9d467257db7a8282a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a241d49eb37b52bd1eadd830af0595319"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classembed_1_1serial.html#a241d49eb37b52bd1eadd830af0595319">flush</a> ()=0</td></tr>
<tr class="memdesc:a241d49eb37b52bd1eadd830af0595319"><td class="mdescLeft">&#160;</td><td class="mdescRight">Set <a class="el" href="classembed_1_1serial.html#a01006e49540c953a3bbc7bdfcb9d05c6" title="The number of bytes that have been buffered. For frames less than 8-bits, each byte holds a frame....">bytes_available()</a> to zero and clear any received data stored in hardware registers. This operation must be faster than simply running <a class="el" href="classembed_1_1serial.html#aff1745f3944aaaf9d467257db7a8282a" title="Read the bytes received over the ports receiver line and stored in the serial implementations buffer....">read()</a> until <a class="el" href="classembed_1_1serial.html#a01006e49540c953a3bbc7bdfcb9d05c6" title="The number of bytes that have been buffered. For frames less than 8-bits, each byte holds a frame....">bytes_available()</a> is empty.  <a href="classembed_1_1serial.html#a241d49eb37b52bd1eadd830af0595319">More...</a><br /></td></tr>
<tr class="separator:a241d49eb37b52bd1eadd830af0595319"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="inherit_header pub_methods_classembed_1_1driver"><td colspan="2" onclick="javascript:toggleInherit('pub_methods_classembed_1_1driver')"><img src="closed.png" alt="-"/>&#160;Public Member Functions inherited from <a class="el" href="classembed_1_1driver.html">embed::driver&lt; serial_settings &gt;</a></td></tr>
<tr class="memitem:a947a3487fa3acd0879e83872d9c97b01 inherit pub_methods_classembed_1_1driver"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classembed_1_1driver.html#a947a3487fa3acd0879e83872d9c97b01">initialize</a> ()</td></tr>
<tr class="memdesc:a947a3487fa3acd0879e83872d9c97b01 inherit pub_methods_classembed_1_1driver"><td class="mdescLeft">&#160;</td><td class="mdescRight">Initialize the driver, apply the setting as defined in the settings_t structure and enable it. Calling this function after it has already been initialized will return false. In order to run initialization again, <a class="el" href="classembed_1_1driver.html#a54440bf23c0c34102f563da1193d99ae" title="Reset the driver in order to run initialize again. This is helpful if the application needs to change...">reset()</a> must be called. After initialization, the settings are committed and saved into another settings structure. This settings can be looked up and inspected by the application.  <a href="classembed_1_1driver.html#a947a3487fa3acd0879e83872d9c97b01">More...</a><br /></td></tr>
<tr class="separator:a947a3487fa3acd0879e83872d9c97b01 inherit pub_methods_classembed_1_1driver"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a54440bf23c0c34102f563da1193d99ae inherit pub_methods_classembed_1_1driver"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classembed_1_1driver.html#a54440bf23c0c34102f563da1193d99ae">reset</a> ()</td></tr>
<tr class="memdesc:a54440bf23c0c34102f563da1193d99ae inherit pub_methods_classembed_1_1driver"><td class="mdescLeft">&#160;</td><td class="mdescRight">Reset the driver in order to run initialize again. This is helpful if the application needs to change the settings of a driver after it is first initialized, like baud rate for serial or pull resistor for a pin.  <a href="classembed_1_1driver.html#a54440bf23c0c34102f563da1193d99ae">More...</a><br /></td></tr>
<tr class="separator:a54440bf23c0c34102f563da1193d99ae inherit pub_methods_classembed_1_1driver"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a346f472e8c212d09c8f45aebd0089d7b inherit pub_methods_classembed_1_1driver"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classembed_1_1driver.html#a346f472e8c212d09c8f45aebd0089d7b">is_initialized</a> () const</td></tr>
<tr class="memdesc:a346f472e8c212d09c8f45aebd0089d7b inherit pub_methods_classembed_1_1driver"><td class="mdescLeft">&#160;</td><td class="mdescRight">Determine if the driver has been initialized.  <a href="classembed_1_1driver.html#a346f472e8c212d09c8f45aebd0089d7b">More...</a><br /></td></tr>
<tr class="separator:a346f472e8c212d09c8f45aebd0089d7b inherit pub_methods_classembed_1_1driver"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae6eb991ebb2321bb3565c2a03a613219 inherit pub_methods_classembed_1_1driver"><td class="memItemLeft" align="right" valign="top"><a class="el" href="structembed_1_1serial__settings.html">serial_settings</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classembed_1_1driver.html#ae6eb991ebb2321bb3565c2a03a613219">settings</a> ()</td></tr>
<tr class="memdesc:ae6eb991ebb2321bb3565c2a03a613219 inherit pub_methods_classembed_1_1driver"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get access to uncommitted driver settings.  <a href="classembed_1_1driver.html#ae6eb991ebb2321bb3565c2a03a613219">More...</a><br /></td></tr>
<tr class="separator:ae6eb991ebb2321bb3565c2a03a613219 inherit pub_methods_classembed_1_1driver"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7e13fe8999142475da8c5b84927f03aa inherit pub_methods_classembed_1_1driver"><td class="memItemLeft" align="right" valign="top">const <a class="el" href="structembed_1_1serial__settings.html">serial_settings</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classembed_1_1driver.html#a7e13fe8999142475da8c5b84927f03aa">initialized_settings</a> () const</td></tr>
<tr class="memdesc:a7e13fe8999142475da8c5b84927f03aa inherit pub_methods_classembed_1_1driver"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get access to the settings that were used in the latest initialization. These settings only get updated when a successful <a class="el" href="classembed_1_1driver.html#a947a3487fa3acd0879e83872d9c97b01" title="Initialize the driver, apply the setting as defined in the settings_t structure and enable it....">initialize()</a> has occurred.  <a href="classembed_1_1driver.html#a7e13fe8999142475da8c5b84927f03aa">More...</a><br /></td></tr>
<tr class="separator:a7e13fe8999142475da8c5b84927f03aa inherit pub_methods_classembed_1_1driver"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="inherited"></a>
Additional Inherited Members</h2></td></tr>
<tr class="inherit_header pro_methods_classembed_1_1driver"><td colspan="2" onclick="javascript:toggleInherit('pro_methods_classembed_1_1driver')"><img src="closed.png" alt="-"/>&#160;Protected Member Functions inherited from <a class="el" href="classembed_1_1driver.html">embed::driver&lt; serial_settings &gt;</a></td></tr>
<tr class="memitem:a1677362481d10c3b48544359daadf081 inherit pro_methods_classembed_1_1driver"><td class="memItemLeft" align="right" valign="top">virtual bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classembed_1_1driver.html#a1677362481d10c3b48544359daadf081">driver_initialize</a> ()=0</td></tr>
<tr class="separator:a1677362481d10c3b48544359daadf081 inherit pro_methods_classembed_1_1driver"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="inherit_header pro_attribs_classembed_1_1driver"><td colspan="2" onclick="javascript:toggleInherit('pro_attribs_classembed_1_1driver')"><img src="closed.png" alt="-"/>&#160;Protected Attributes inherited from <a class="el" href="classembed_1_1driver.html">embed::driver&lt; serial_settings &gt;</a></td></tr>
<tr class="memitem:afb925433a5897293609af5fae29e3dc3 inherit pro_attribs_classembed_1_1driver"><td class="memItemLeft" align="right" valign="top"><a class="el" href="structembed_1_1serial__settings.html">serial_settings</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classembed_1_1driver.html#afb925433a5897293609af5fae29e3dc3">m_settings</a></td></tr>
<tr class="separator:afb925433a5897293609af5fae29e3dc3 inherit pro_attribs_classembed_1_1driver"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aac7d23e384bc27a26b77c8fd681483ef inherit pro_attribs_classembed_1_1driver"><td class="memItemLeft" align="right" valign="top"><a class="el" href="structembed_1_1serial__settings.html">serial_settings</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classembed_1_1driver.html#aac7d23e384bc27a26b77c8fd681483ef">m_initialized_settings</a></td></tr>
<tr class="separator:aac7d23e384bc27a26b77c8fd681483ef inherit pro_attribs_classembed_1_1driver"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab8b2029f33d55b9ffffd6e88d846cd7b inherit pro_attribs_classembed_1_1driver"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classembed_1_1driver.html#ab8b2029f33d55b9ffffd6e88d846cd7b">m_initialized</a></td></tr>
<tr class="separator:ab8b2029f33d55b9ffffd6e88d846cd7b inherit pro_attribs_classembed_1_1driver"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<div class="textblock"><p>Serial communication protocol hardware abstract interface. Use this interface for hardware that implements a serial protocol like UART, USART, RS232, RS485 and many others that use a similar communication protocol but may use different voltage schemes. </p>
<p>Due to the asynchronous nature of serial communication protocols, all implementations of serial devices MUST buffer received bytes using DMA or interrupts. A thread should not be used as this generally greatly increases the ROM and RAM cost of using library.</p>
<p>All implementations MUST allow the user to supply their own buffer of arbitrary size, such that the amount of buffered data can be tailored to the needs of the application. </p>
</div><h2 class="groupheader">Member Function Documentation</h2>
<a id="acaa9db822945c72a220f2ca7c4c03ab9"></a>
<h2 class="memtitle"><span class="permalink"><a href="#acaa9db822945c72a220f2ca7c4c03ab9">&#9670;&nbsp;</a></span>busy()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual bool embed::serial::busy </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">pure virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Determines if the write operation is currently on going. </p>
<dl class="section return"><dt>Returns</dt><dd>true serial transmitter is currently writing data to the port </dd>
<dd>
false serial transmitter is idle and available to write data </dd></dl>

</div>
</div>
<a id="a01006e49540c953a3bbc7bdfcb9d05c6"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a01006e49540c953a3bbc7bdfcb9d05c6">&#9670;&nbsp;</a></span>bytes_available()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual size_t embed::serial::bytes_available </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">pure virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>The number of bytes that have been buffered. For frames less than 8-bits, each byte holds a frame. For frames above 8-bits the number of bytes returned indicates the number of bytes a buffer needs to be to return all of the data held in the buffer. </p>
<dl class="section return"><dt>Returns</dt><dd>size_t number of buffered by the serial driver and are available to be read by the <a class="el" href="classembed_1_1serial.html#aff1745f3944aaaf9d467257db7a8282a" title="Read the bytes received over the ports receiver line and stored in the serial implementations buffer....">read()</a> function. </dd></dl>

</div>
</div>
<a id="a241d49eb37b52bd1eadd830af0595319"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a241d49eb37b52bd1eadd830af0595319">&#9670;&nbsp;</a></span>flush()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual void embed::serial::flush </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">pure virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Set <a class="el" href="classembed_1_1serial.html#a01006e49540c953a3bbc7bdfcb9d05c6" title="The number of bytes that have been buffered. For frames less than 8-bits, each byte holds a frame....">bytes_available()</a> to zero and clear any received data stored in hardware registers. This operation must be faster than simply running <a class="el" href="classembed_1_1serial.html#aff1745f3944aaaf9d467257db7a8282a" title="Read the bytes received over the ports receiver line and stored in the serial implementations buffer....">read()</a> until <a class="el" href="classembed_1_1serial.html#a01006e49540c953a3bbc7bdfcb9d05c6" title="The number of bytes that have been buffered. For frames less than 8-bits, each byte holds a frame....">bytes_available()</a> is empty. </p>

</div>
</div>
<a id="aff1745f3944aaaf9d467257db7a8282a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aff1745f3944aaaf9d467257db7a8282a">&#9670;&nbsp;</a></span>read()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual std::span&lt;const std::byte&gt; embed::serial::read </td>
          <td>(</td>
          <td class="paramtype">std::span&lt; std::byte &gt;&#160;</td>
          <td class="paramname"><em>p_data</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">pure virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Read the bytes received over the ports receiver line and stored in the serial implementations buffer. The number of bytes read will subtract the number of bytes available until it reaches zero. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">p_data</td><td>Buffer to read bytes back from. If the length of this buffer is greater than the value returned by <a class="el" href="classembed_1_1serial.html#a01006e49540c953a3bbc7bdfcb9d05c6" title="The number of bytes that have been buffered. For frames less than 8-bits, each byte holds a frame....">bytes_available()</a> then buffer is filled up to the length returned by <a class="el" href="classembed_1_1serial.html#a01006e49540c953a3bbc7bdfcb9d05c6" title="The number of bytes that have been buffered. For frames less than 8-bits, each byte holds a frame....">bytes_available()</a>. The rest of the buffer is left untouched. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>std::span&lt;const std::byte&gt; provides a means to get the length of bytes read into the buffer p_data. The address will ALWAYS be the same as p_data and the length will be equal to the number of bytes read from the buffer. </dd></dl>

</div>
</div>
<a id="a2632150facd5b70f49dedea7108679d6"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2632150facd5b70f49dedea7108679d6">&#9670;&nbsp;</a></span>write()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual void embed::serial::write </td>
          <td>(</td>
          <td class="paramtype">std::span&lt; const std::byte &gt;&#160;</td>
          <td class="paramname"><em>p_data</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">pure virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Write data on the transmitter line of the port. The exact implementation for this can be polling, interrupt driven or DMA driven. There is no guarantee on exactly how a write operation will operate, thus the <a class="el" href="classembed_1_1serial.html#acaa9db822945c72a220f2ca7c4c03ab9" title="Determines if the write operation is currently on going.">busy()</a> function must polled called after this returns to determine if the write operation has finished. Attempting to call <a class="el" href="classembed_1_1serial.html#a2632150facd5b70f49dedea7108679d6" title="Write data on the transmitter line of the port. The exact implementation for this can be polling,...">write()</a> when tranmission is busy is undefined behavior. </p>
<p>Data frames are not compact when frame size is less than 8 bits. Meaning that, if you want to send three 5-bit frames, then you will need to use a span of at least 3 bytes to hold each value.</p>
<p>When writing data with frame size greater than 8 is in little endian order. Meaning that the first byte in the sequence is the lower byte and the next is the greater byte. If you wanted to send a 9-bit frame with value 0x14A, the first byte must be 0x4A and the next 0x01.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">p_data</td><td>data to be transmitted over the serial port transmitter line </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<hr/>The documentation for this class was generated from the following file:<ul>
<li>/github/workspace/include/libembeddedhal/serial/<a class="el" href="serial_8hpp_source.html">serial.hpp</a></li>
</ul>
</div><!-- contents -->
<!-- start footer part -->
<hr class="footer"/><address class="footer"><small>
Generated by&#160;<a href="https://www.doxygen.org/index.html"><img class="footer" src="doxygen.svg" width="104" height="31" alt="doxygen"/></a> 1.9.1
</small></address>
</body>
</html>
